<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fate0</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.fatezero.org/"/>
  <updated>2018-03-04T14:02:22.363Z</updated>
  <id>http://blog.fatezero.org/</id>
  
  <author>
    <name>fate0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬虫基础篇[Web 漏洞扫描器]</title>
    <link href="http://blog.fatezero.org/2018/03/05/web-scanner-crawler-01/"/>
    <id>http://blog.fatezero.org/2018/03/05/web-scanner-crawler-01/</id>
    <published>2018-03-05T00:00:24.000Z</published>
    <updated>2018-03-04T14:02:22.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Web 漏扫的爬虫和其他的网络爬虫的技术挑战不太一样，漏扫的爬虫不仅仅需要爬取网页内容、分析链接信息，还需要尽可能多的触发网页上的各种事件，以便获取更多的有效链接信息。总而言之，Web 漏扫的爬虫需要不择手段的获取尽可能多新的链接信息。</p><a id="more"></a><p>在这篇博客文章中，我打算简单地介绍下和爬虫浏览器相关内容，爬虫基础篇倒不是说内容基础，而是这部分内容在漏扫爬虫中的地位是基础的。</p><h2 id="0x01-QtWebkit-or-Headless-Chrome"><a href="#0x01-QtWebkit-or-Headless-Chrome" class="headerlink" title="0x01 QtWebkit or Headless Chrome"></a>0x01 QtWebkit or Headless Chrome</h2><blockquote><p>QtWebkit or Headless Chrome, that is a question</p></blockquote><p>QtWebkit 还是 Headless Chrome，我们一个一个分析。</p><h4 id="QtWebkit"><a href="#QtWebkit" class="headerlink" title="QtWebkit"></a>QtWebkit</h4><p>我们先说一下在漏扫爬虫和 QtWebkit 相关的技术:</p><ul><li>使用 QtWebkit</li><li>使用 PhantomJS (基于 Qt 编写)</li><li>使用 PyQt (一个 Python 的 Qt bindings)</li></ul><p>这也是我之前在 TangScan 调研 QtWebkit 系列的时候面对的技术，当时就首先就排除了 PyQt，因为在 PyQt 中没有办法自定义 <a href="http://doc.qt.io/qt-5/qpa.html" target="_blank" rel="noopener">QPA</a> 插件，如果不借用 xvfb，是没法在没有 X Server 的服务器上跑起来的，本来 PyQt 已经够慢，再加上一个 xvfb，那就更慢了，所以直接排除 PyQt。</p><p>接着讨论 PhantomJS，PhantomJS 的优点是简单，不需要再次开发，直接使用 js 就可以操作一个浏览器，所以 TangScan 内部的第一个版本也选择了 PhantomJS，但后面也发现了 PhantomJS 的不足。</p><p>首先 PhantomJS 可以使用 js 操作浏览器是个优点，但也必须多出一个 js context (QWebPage) 开销，而且有时候 js 的 callback 在一些情况下没有被调用。其次我所需要的功能 PhantomJS 并没有提供，然而在 QtWebkit 中可以实现。</p><p>所以 TangScan 内部的第二版，我选择了使用 QtWebkit 来重新写一个类似 PhantomJS 的东西 (内部名为 CasterJS，AWVS 也是用 QtWebkit 写了个名为 marvin 的爬虫)。</p><p>但是直接使用 QtWebkit 还是有问题。首先自从 Qt5.2 之后，对应的 WebKit 引擎就没有再更新过，别说支持 ES6 了，函数连 <code>bind</code> 方法都没有。其次内存泄漏问题严重，最明显的情况就是设置默认不加载图片 <code>QWebSettings::AutoLoadImages</code> 的时候，内存使用率蹭蹭地往上涨。最后也是最严重的问题，稳定性欠缺，也是自己实现了 CasterJS 之后才知道为什么 PhantomJS 上为什么会有那么多没处理的 issue，这个不稳定的原因是第三方库不稳定 (老旧的 Webkit)，自己还不能更换这个第三方库。当时在 TangScan 的时候，就非常头疼这些明知道不是自己的锅、解决起来特麻烦、还必须得解决的问题。</p><p>所以如果没有其他选择，QtWebkit 忍一忍还是能继续使用下去，但是 Headless Chrome 出现了。</p><h4 id="Headless-Chrome"><a href="#Headless-Chrome" class="headerlink" title="Headless Chrome"></a>Headless Chrome</h4><p>Chrome 的 Headless 模式在 2015-08 开始低调开发，2016-06 开始对外公开，2017-04 在 M59 上正式发布。</p><p>后来 PhantomJS 的开发者 Vitaly Slobodin 在 PhantomJS 邮件组发出了公告 <a href="https://groups.google.com/forum/#!topic/phantomjs/9aI5d-LDuNE" target="_blank" rel="noopener">[Announcement] Stepping down as maintainer</a>，听到这个消息我真的一点都不意外，在 TangScan 中，也是使用 Qt 从头开发起 CasterJS 的我来说，已经受够了由于老旧的 Webkit 版本带来的各种 crash，内存泄漏，QtWebkit 这个坑实在是太坑了。</p><p>Vitaly Slobodin 在当时作为 PhantomJS 唯一的主要开发者，面对着 PhantomJS 项目上那接近 2k 的 issue，心有余而力不足，而且 crash 问题占多数。虽然说很多问题上游的 Webkit 已经解决了，但偏偏 Qt 一直绑定的都是 Webkit 几年前的版本，所以 Vitaly Slobodin 就真的自个单独维护一个 QtWebkit 仓库，用于专门解决这样的问题。但是作为 PhantomJS 唯一的开发者，既要开发新功能，又要持续跟进 QtWebkit 各种 BUG，力不从心。然后雪上加霜的是 Qt 在 Qt 5.2 的时候宣布打算放弃 QtWebkit，不在进行更新，转而使用基于 Chromium 的 QWebEngine 取代 QtWebkit。虽然后来 <a href="https://github.com/annulen/webkit/releases" target="_blank" rel="noopener">annulen</a> 扛起了大旗，说要继续维护 QtWebkit，要从 Webkit 那里一点一点地更新代码，但个人开发速度还是比不上一个团队。这个时候 Headless Chrome 出来了，Vitaly Slobodin 在这个时候退出 PhantomJS 的开发是最好的选择了。</p><p>Headless Chrome 的出现也让我哭笑不得，哭的原因是因为 Headless Chrome 让我在 TangScan 开发的 CasterJS 变得毫无意义，笑的原因因为 Headless Chrome 比其他基于 QtWebkit 写的 Headless 浏览器更快速、稳定、简单，让我跳出了 QtWebkit 这个坑。</p><p>夸了那么久 Headless Chrome 不过也并不代表 Headless Chrome 毫无缺点，首先 Chrome 的 Headless 模式算是一个比较新的特性，一些功能还不算完善，只能等官方实现或者自行实现(比方说 interception 这个功能我就等了几个月)。其次 CDP 所提供的 API 不稳定，还会存在变动(比方说 M63 和 M64 中 <code>Network.continueInterceptedRequest</code> 的变动)，所以在使用 Headless Chrome 的时候，一定要先确定的 Chrome 版本，再编写和 CDP 相关的代码。</p><p>当然我也发现有些公司内部扫描器在使用 IE，大致过了一遍代码，我个人并不觉得这是个好方案，所以我还是坚持使用 Headless Chrome。</p><h2 id="0x02-小改-Chromium"><a href="#0x02-小改-Chromium" class="headerlink" title="0x02 小改 Chromium"></a>0x02 小改 Chromium</h2><p>OK，既然我们已经选定了 Headless Chrome，是不是可以撸起袖子开始干了呢，很抱歉，目前 Headless Chrome 还是不太满足我们扫描器爬虫的需求，我们还需要对其代码进行修改。</p><p>官方文档很详细的介绍了如何编译、调试 Chromium，只要网络没问题(需翻墙)，一般也不会遇到什么大问题，所以这里也没必要介绍相关知识。</p><h4 id="hook-location"><a href="#hook-location" class="headerlink" title="hook location"></a>hook location</h4><p>我们先看一下这个例子</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">window.location = '/test1';</span></span><br><span class="line"><span class="undefined">window.location = '/test2';</span></span><br><span class="line"><span class="undefined">window.location = '/test3';</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个场景面临的问题和 <a href="https://github.com/bedirhan/wivet/blob/master/pages/9.php" target="_blank" rel="noopener">wivet - 9.php</a> 有点儿类似: 怎么样把所有跳转链接给抓取下来?</p><p>可能熟悉 QtWebkit 的同学觉得直接实现 <code>QWebPage::acceptNavigationRequest</code> 虚函数就可以拦截所有尝试跳转的请求.</p><p>可能熟悉 Headless Chrome 的同学会说在 CDP 中也有 <code>Network.continueInterceptedRequest</code> 可以拦截所有网络请求，当然也包括跳转的请求。</p><p>但实际上这两种方法都只能获取到最后一个 <code>/test3</code> 链接，因为前面两次跳转都很及时的被下一次跳转给中断了，所以更不会尝试发出跳转请求，类似 intercept request 的 callback 就不可能获取到所有跳转的链接。</p><p>要是 location 能够使用 <code>defineProperty</code> 进行修改，那问题就简单多了。但是在一般的浏览器中 location 都是 unforgeable 的，也就是不能使用 <code>defineProperty</code> 进行修改，不过现在 Chromium 代码在我们手上，所以完全可以将其修改为可修改的，直接修改 location 对应的 idl 文件即可:</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/third_party/WebKit/Source/core/frame/Window.idl</span></span><br><span class="line"><span class="comment">+++ b/third_party/WebKit/Source/core/frame/Window.idl</span></span><br><span class="line"><span class="meta">@@ -39,7 +39,7 @@</span></span><br><span class="line">     [Unforgeable, CachedAccessor] readonly attribute Document document;</span><br><span class="line">     [Replaceable] readonly attribute DOMString origin;</span><br><span class="line">     attribute DOMString name;</span><br><span class="line"><span class="deletion">-    [PutForwards=href, Unforgeable, CrossOrigin=(Getter,Setter), Custom=Getter] readonly attribute Location location;</span></span><br><span class="line"><span class="addition">+    [PutForwards=href, CrossOrigin=(Getter,Setter), Custom=Getter] readonly attribute Location location;</span></span><br><span class="line">     readonly attribute History history;</span><br><span class="line">     [Replaceable, MeasureAs=BarPropLocationbar] readonly attribute BarProp locationbar;</span><br><span class="line">     [Replaceable, MeasureAs=BarPropMenubar] readonly attribute BarProp menubar;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/third_party/WebKit/Source/core/dom/Document.idl</span></span><br><span class="line"><span class="comment">+++ b/third_party/WebKit/Source/core/dom/Document.idl</span></span><br><span class="line">@@ -92,7 +92,7 @@ typedef (HTMLScriptElement or SVGScriptElement) HTMLOrSVGScriptElement;</span><br><span class="line"> </span><br><span class="line">     // resource metadata management</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-    [PutForwards=href, Unforgeable] readonly attribute Location? location;</span></span><br><span class="line"><span class="addition">+    [PutForwards=href] readonly attribute Location? location;</span></span><br><span class="line">     [RaisesException=Setter] attribute DOMString domain;</span><br><span class="line">     readonly attribute DOMString referrer;</span><br><span class="line">     [RaisesException, RuntimeCallStatsCounter=DocumentCookie] attribute DOMString cookie;</span><br></pre></td></tr></table></figure><p>测试代码:<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">Object.defineProperty(window, "location", &#123;</span></span><br><span class="line"><span class="undefined">    set: function (newValue) &#123;</span></span><br><span class="line"><span class="undefined">        console.log("new value: " + newValue);</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    get: function () &#123;</span></span><br><span class="line"><span class="undefined">        console.log("get value");</span></span><br><span class="line"><span class="undefined">        return 123;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">console.log(document.location);</span></span><br><span class="line"><span class="undefined">console.log(window.location);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>修改前:</p><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-01/locaiton_error.png" width="500"><p>修改后:</p><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-01/location_unforgeable.png" width="500"><p>我之所以觉得伪造 location 这个特性很重要，是因为不仅仅在爬虫中需要到这个特性，在实现 DOM XSS 检测的时候这个特性也非常重要，虽然说 Headless Chrome 官方文档上有提过将来可能会让用户可以自由 hook location 的特性 (官方文档上也是考虑到 DOM XSS 这块)，但过了将近一年的时间，也没有和这个特性的相关消息，所以还是自己动手丰衣足食。</p><h4 id="popups-窗口"><a href="#popups-窗口" class="headerlink" title="popups 窗口"></a>popups 窗口</h4><p>我们再来看看这个例子</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.qq.com"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">name</span>=<span class="string">"popup"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    document.getElementsByName("popup")[0].submit();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Headless Chrome 中会直接弹出一个 popups 窗口，CDP 只能禁止当前 page 跳转，但是没办法禁止新 page 创建，在 QtWebkit 中并没有这样的烦恼，因为所有的跳转请求都由 <code>QWebPage::acceptNavigationRequest</code> 决定去留。</p><p>这个问题是 DM 同学提出来的，当时他和我讨论该问题。其实当时我也没有解决方法，于是我跑去 Headless Chrome 邮件组问了开发人员 <a href="https://groups.google.com/a/chromium.org/forum/#!topic/headless-dev/gmZU6xBv3Jk" target="_blank" rel="noopener">Is there any way to block popups in headless mode?</a>，开发人员建议我先监听 <code>Page.windowOpen</code> 或 <code>Target.targetCreated</code> 事件，然后再使用 <code>Target.closeTarget</code> 关闭新建的 popups 窗口。</p><p>那么问题就来了，首先如果等待 page 新建之后再去关闭，不仅仅浪费资源去新建一个无意义的 page，而且 page 对应的网络请求已经发送出去了，如果该网络请求是一个用户退出的请求，那么事情就更严重了。其次开发人员推荐的方法是没法区分新建的 page 是在某个 page 下新建的，还是通过 CDP 新建的。所以 Headless Chrome 开发人员的建议我并不是特别满意。</p><p>得，最好的办法还是继续修改代码，使其在 page 中无法新建 page：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/third_party/WebKit/Source/core/page/CreateWindow.cpp</span></span><br><span class="line"><span class="comment">+++ b/third_party/WebKit/Source/core/page/CreateWindow.cpp</span></span><br><span class="line">@@ -282,6 +282,9 @@ static Frame* CreateNewWindow(LocalFrame&amp; opener_frame,</span><br><span class="line">                               const WebWindowFeatures&amp; features,</span><br><span class="line">                               NavigationPolicy policy,</span><br><span class="line">                               bool&amp; created) &#123;</span><br><span class="line"><span class="addition">+  // add by fate0</span></span><br><span class="line"><span class="addition">+  return nullptr;</span></span><br><span class="line"><span class="addition">+  </span></span><br><span class="line">   Page* old_page = opener_frame.GetPage();</span><br><span class="line">   if (!old_page)</span><br><span class="line">     return nullptr;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/third_party/WebKit/Source/core/page/CreateWindow.cpp</span></span><br><span class="line"><span class="comment">+++ b/third_party/WebKit/Source/core/page/CreateWindow.cpp</span></span><br><span class="line">@@ -396,6 +396,10 @@ DOMWindow* CreateWindow(const String&amp; url_string,</span><br><span class="line">                         LocalFrame&amp; first_frame,</span><br><span class="line">                         LocalFrame&amp; opener_frame,</span><br><span class="line">                         ExceptionState&amp; exception_state) &#123;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  // add by fate0</span></span><br><span class="line"><span class="addition">+  return nullptr;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   LocalFrame* active_frame = calling_window.GetFrame();</span><br><span class="line">   DCHECK(active_frame);</span><br></pre></td></tr></table></figure><h4 id="忽略-SSL-证书错误"><a href="#忽略-SSL-证书错误" class="headerlink" title="忽略 SSL 证书错误"></a>忽略 SSL 证书错误</h4><p>在 Headless Chrome 对外公开之后很长一段时间内，是没法通过 devtools 控制忽略 SSL 证书错误的，也没办法去拦截 Chrome 的各种网络请求。</p><p>直到<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=659662" target="_blank" rel="noopener">2017-03</a> 才实现了在 devtools 上控制忽略 SSL 证书错误的功能。</p><p>直到<a href="https://groups.google.com/a/chromium.org/forum/#!topic/headless-dev/uvms04dXTIM" target="_blank" rel="noopener">2017-06</a> 才实现了在 devtools 可以拦截并修改 Chrome 网络请求的功能。</p><p>这两个特性对于扫描器爬虫来说非常重要，尤其是拦截网络请求的功能，可偏偏这两功能结合在一起使用的时候，就会出现 BUG，在 puppeteer 上也有人提了 <a href="https://github.com/GoogleChrome/puppeteer/issues/1159" target="_blank" rel="noopener">ignoreHTTPSErrors is not working when request interception is on</a>，直至现在(2018-03-05)，Google 也并没有修复该 BUG，我还能说啥呢，还是自己动手，丰衣足食。</p><p>最简单的方法就是修改 Chromium 代码直接忽略所有的网站的 SSL 证书错误，这样也省了一个 CDP 的 callback，修改如下:</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/net/http/http_network_session.cc</span></span><br><span class="line"><span class="comment">+++ b/net/http/http_network_session.cc</span></span><br><span class="line">@@ -97,7 +97,7 @@ SettingsMap AddDefaultHttp2Settings(SettingsMap http2_settings) &#123;</span><br><span class="line"> </span><br><span class="line"> HttpNetworkSession::Params::Params()</span><br><span class="line">     : enable_server_push_cancellation(false),</span><br><span class="line"><span class="deletion">-      ignore_certificate_errors(false),</span></span><br><span class="line"><span class="addition">+      ignore_certificate_errors(true),</span></span><br><span class="line">       testing_fixed_http_port(0),</span><br><span class="line">       testing_fixed_https_port(0),</span><br><span class="line">       tcp_fast_open_mode(TcpFastOpenMode::DISABLED),</span><br></pre></td></tr></table></figure><p>测试环境 <a href="https://badssl.com" target="_blank" rel="noopener">badssl.com</a></p><p>在 Chromium 中还有一些其他可改可不改的地方，这里就不继续吐槽了。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>OK，折腾了那么久，终于把一个类似 wget 的功能实现好了(笑，相对于我之前基于 QtWebkit 从头实现一个类似 PhantomJS 的 CasterJS 来说，目前使用 Headless Chrome 稳定、可靠、快速，简直是漏扫爬虫的不二选择。</p><p>这篇博客就简单讲了一下和漏扫爬虫相关的 Headless 浏览器的知识，接下来就到了漏扫爬虫中最为重要的一点，这一点也就决定了漏扫爬虫链接抓取效果是否会比其他扫描器好，能好多少，这都会在扫描器的下一篇文章中继续介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;Web 漏扫的爬虫和其他的网络爬虫的技术挑战不太一样，漏扫的爬虫不仅仅需要爬取网页内容、分析链接信息，
还需要尽可能多的触发网页上的各种事件，以便获取更多的有效链接信息。
总而言之，Web 漏扫的爬虫需要不择手段的获取尽可能多新的链接信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web 漏洞扫描器" scheme="http://blog.fatezero.org/tags/Web-%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Package 钓鱼</title>
    <link href="http://blog.fatezero.org/2017/06/01/package-fishing/"/>
    <id>http://blog.fatezero.org/2017/06/01/package-fishing/</id>
    <published>2017-06-01T20:47:24.000Z</published>
    <updated>2018-03-04T14:02:22.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前几天 <code>Samba</code> 公开了一个远程代码执行的漏洞，然后各种 POC 也随之出现，<code>exploit-db</code> 上也有这样一个 Python 版本的 <a href="https://www.exploit-db.com/exploits/42060/" target="_blank" rel="noopener">POC:  Samba 3.5.0 - Remote Code Execution</a>.</p><a id="more"></a><p>直接执行 POC，报错误信息：</p><img src="http://static.fatezero.org/blog/img/package-fishing/run-poc-at-the-first-time.png"><p>这种情况非常简单，直接 <code>pip install smb</code> 就行，但是：</p><img src="http://static.fatezero.org/blog/img/package-fishing/install-smb-package.png"><p>好吧，我们还是需要 Google 一下这个 <code>smb</code> 的 package 名字，最后发现原来是 <code>pysmb</code>：</p><img src="http://static.fatezero.org/blog/img/package-fishing/install-pysmb-and-run-poc.png"><p>最后 POC 终于跑了起来.</p><p>我们再回过头来看看整个流程，似乎并没有什么地方不对劲。</p><p>直接说问题所在吧，如果你在 <code>2017-05-24</code> 到 <code>2017-05-31</code> 这段时间内执行过 <code>pip install smb</code> 或者 <code>pip download smb</code>，那么恭喜你，你的名字可能出现在我的绵羊墙上。</p><h3 id="0x01-试水-2017-05-23-19-00"><a href="#0x01-试水-2017-05-23-19-00" class="headerlink" title="0x01 试水 (2017-05-23 19:00)"></a>0x01 试水 (2017-05-23 19:00)</h3><p>第一天，我在 PyPI 上投放了 4 个 evil package: <code>python-dev</code>、<code>mongodb</code>、<code>proxy</code>、<code>shadowsock</code> 测试一下不检查 package、随意安装 package 的人有多少。</p><p>其中所有的内容都是用 <code>cookiecutter</code> 根据模版 <a href="https://github.com/fate0/cookiecutter-evilpy-package/tree/cf812e1f44ca052b5e7055a8ff8cf5c4d81dcf98" target="_blank" rel="noopener">cookiecutter-evilpy-package</a> 生成。</p><p>每个 package 都会收集用户的</p><ul><li>username</li><li>hostname</li><li>ip</li><li>hostinfo</li></ul><p>我选择了 GitHub Issues + webtask.io 的方式，将安装 evil package 的用户信息通过 webtask.io 中转到 GitHub Issues 上对外公开。</p><p>所以我就在 Github 上注册了个小马甲 <a href="https://github.com/evilpackage" target="_blank" rel="noopener">evilpackage</a> 专门提交 Issue。</p><p>因为 webtask.io 获取客户端 ip 的时候，其实获取到的是 webtask.io 前面 nginx 的 ip 地址，并不是用户的 ip，所以就只能在代码里面获取客户端的外网 ip.使用 webtask.io 和 GitHub Issues 的主要原因是这两都是免费的。</p><h2 id="0x02-增加投放-package-2017-05-24-19-00"><a href="#0x02-增加投放-package-2017-05-24-19-00" class="headerlink" title="0x02 增加投放 package (2017-05-24 19:00)"></a>0x02 增加投放 package (2017-05-24 19:00)</h2><p>查看了一天的 Issues 数量，大概有 700+，效果非常不错，决定继续投放 evil package。与此同时，@<a href="http://weibo.com/u/1260091985" target="_blank" rel="noopener">ztz</a> 同学也加入了游戏，也在 RubyGems 上投放 Gems。</p><p>继续投放 evil package，就必须想一些比较好的名字，我主要使用下面两种方法:</p><ol><li><p>Google 搜索提示框<br>直接根据 Google 的搜索框提示:</p><img src="http://static.fatezero.org/blog/img/package-fishing/google-search-input-list.png"><p>便收集到了没有在 PyPI 上注册，而且比较流行的 Package 名字:</p><ul><li>caffe</li><li>ffmpeg</li><li>git</li><li>mkl</li><li>opencl</li><li>opencv</li><li>openssl</li><li>pygpu</li><li>tkinter</li><li>vtk</li><li>proxy</li></ul></li><li><p>想象力<br>依据平时写代码的经验总结出下面可能觉得会常用，但并没有在 PyPI 上注册的 Package 名字:</p><ul><li>ftp</li><li>smb</li><li>hbase</li><li>samba</li><li>rabbitmq</li><li>zookeeper</li><li>phantomjs</li><li>memcached</li><li>requirement.txt</li><li>requirements.txt</li></ul></li></ol><p>其中 <code>requirements.txt</code> 并没有注册成功，稍后再说。</p><h2 id="0x03-暂停服务-2017-05-25-23-00"><a href="#0x03-暂停服务-2017-05-25-23-00" class="headerlink" title="0x03 暂停服务 (2017-05-25 23:00)"></a>0x03 暂停服务 (2017-05-25 23:00)</h2><p>晚上回家的时候又统计了一下安装量，一天安装量达到了 2000+，效果已经很显著，不必再增加新的 package 了，但是到了晚上 23:00 的时候，我的 GitHub Issues 被恶意插入脏数据，所以只能暂停服务：</p><img src="http://static.fatezero.org/blog/img/package-fishing/insert-useless-data.png"><p>之所以只能暂停服务，那是因为 webtask.io 没法获取客户端 ip，我也没法 ban 掉对应的 ip，作出任何相对的处理，只能停服务。</p><p>话说到底谁才是攻击者。</p><h2 id="0x04-evilpackage-被封-2017-05-26-2-00"><a href="#0x04-evilpackage-被封-2017-05-26-2-00" class="headerlink" title="0x04 evilpackage 被封 (2017-05-26 2:00)"></a>0x04 evilpackage 被封 (2017-05-26 2:00)</h2><p>我专门提交 Issue 的小马甲 <a href="https://github.com/evilpackage" target="_blank" rel="noopener">evilpackage</a> 因为触发了 GitHub 对 Spam 的检测，所以被封号了。早上起床看到消息后，立马写邮件申诉，直到 2017-05-26 13:00 终于回复我的邮件了：</p><img src="http://static.fatezero.org/blog/img/package-fishing/unlock-evilpackage.png"><h2 id="0x05-放弃-webtask-io-2017-05-26-19-00"><a href="#0x05-放弃-webtask-io-2017-05-26-19-00" class="headerlink" title="0x05 放弃 webtask.io (2017-05-26 19:00)"></a>0x05 放弃 webtask.io (2017-05-26 19:00)</h2><p>为了避免和之前一样被恶意插入脏数据，决定要放弃 webtask.io，每月花费 $10 巨款购入一台 vps。</p><p>使用 nginx + flask 的配置，继续将 user data 提交到 GitHub Issues 上。</p><p>nginx 的 <code>ngx_http_limit_req_module</code> 模块最大能够支持 <code>1s/m</code>，也就是最多可以限制每个 ip 在每分钟内最多请求一次，所以我们必须修改 <code>ngx_http_limit_req_module</code> 模块代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/http/modules/ngx_http_limit_req_module.c</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ngx_strncmp(value[i].data, <span class="string">"rate="</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            len = value[i].len;</span><br><span class="line">            p = value[i].data + len - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ngx_strncmp(p, <span class="string">"r/s"</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                scale = <span class="number">1</span>;</span><br><span class="line">                len -= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ngx_strncmp(p, <span class="string">"r/m"</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                scale = <span class="number">60</span>;</span><br><span class="line">                len -= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ngx_strncmp(p, <span class="string">"wtf"</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                scale = <span class="number">1000</span>;</span><br><span class="line">                len -= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>增加一个 <code>else if</code> block，直接将 scale 增加到 1000，这样就能限制每个 ip 在 16 min 内只能访问一次我们的接口，除非使用大量代理，不然很难在短时间内插入大量脏数据。</p><h2 id="0x06-repo-被封-2017-05-27-3-00"><a href="#0x06-repo-被封-2017-05-27-3-00" class="headerlink" title="0x06 repo 被封 (2017-05-27 3:00)"></a>0x06 repo 被封 (2017-05-27 3:00)</h2><p>早上起床刷新一下 GitHub Issues 页面，结果发现：</p><img src="http://static.fatezero.org/blog/img/package-fishing/lock-repo.png"><p>邮件：</p><img src="http://static.fatezero.org/blog/img/package-fishing/lock-repo-email.png"><p>赶紧先上服务器加上一行代码，将用户上传的数据先暂时存在本地（之前太懒）。然后马上回邮件，问情况，两天后：</p><img src="http://static.fatezero.org/blog/img/package-fishing/lock-repo-response-email.png"><p>解封无望，之前的数据大概就是没了。</p><p>目前还能通过 GitHub Search 找到以前的部分数据 <a href="https://github.com/search?l=&amp;q=repo%3Afate0%2Fcookiecutter-evil-pypackage&amp;ref=advsearch&amp;type=Issues&amp;utf8=%E2%9C%93" target="_blank" rel="noopener">GitHub Issue</a></p><h2 id="0x07-写-web-界面-2017-05-30-19-00"><a href="#0x07-写-web-界面-2017-05-30-19-00" class="headerlink" title="0x07 写 web 界面 (2017-05-30 19:00):"></a>0x07 写 web 界面 (2017-05-30 19:00):</h2><p>由于之前一直在忙，最后拖到了30号才开始写 web 展示界面 <a href="http://evilpackage.fatezero.org/" target="_blank" rel="noopener">http://evilpackage.fatezero.org/</a></p><p>也准备好新的 cookiecutter 模版 <a href="https://github.com/fate0/cookiecutter-evilpy-package/commit/b1a968407b1a94b17298af969727848ad1325cae" target="_blank" rel="noopener">cookiecutter-evilpy-package</a></p><p>新的 cookiecutter 模版会提示用户安装了 evilpackage，并打开用户的浏览器去访问 <a href="http://evilpackage.fatezero.org/" target="_blank" rel="noopener">http://evilpackage.fatezero.org/</a>，让用户知道，自己已经是绵羊墙上的一员了。</p><p>计划打算第二天再往 PyPI 上提交新版本的 Package。</p><h2 id="0x08-清空-2017-05-31"><a href="#0x08-清空-2017-05-31" class="headerlink" title="0x08 清空 (2017-05-31):"></a>0x08 清空 (2017-05-31):</h2><p>早上查找资料的时候发现，原来已经有好几批人干过和我一样类似的事情了</p><ul><li>2013-06-06: <a href="https://pypi.python.org/pypi/requestes" target="_blank" rel="noopener">requestes 0.0.1</a></li><li>2016-01-25: <a href="https://pypi.python.org/pypi/requirements-dev/1.0.0" target="_blank" rel="noopener">requirements-dev 1.0.0</a></li><li>2016-03-17: <a href="http://incolumitas.com/data/thesis.pdf" target="_blank" rel="noopener">Typosquatting in Programming Language Package Managers</a> </li></ul><p>前两批都只是上传一个 package 用来提示安装用户，也防止恶意用户使用这些 package 名字，后面一个小哥和我一样收集了用户不太敏感的信息，只不过他的数据一直没有公开。</p><p>过了一会 @<a href="http://weibo.com/u/1260091985" target="_blank" rel="noopener">ztz</a> 同学告诉我他的 RubyGems 被清空了。</p><p>再过了一会我这边也被 PyPI 管理员警告要删除账号了，所以我就把所有的 Package 给删除了，账号也给删除了。</p><p>目前为止所有的 package 又回到了 unregister 的状态, 任何人都可以继续注册使用我之前注册的 package.</p><h2 id="0x09-数据统计"><a href="#0x09-数据统计" class="headerlink" title="0x09 数据统计"></a>0x09 数据统计</h2><p>目前我只能对在 <a href="http://evilpackage.fatezero.org/" target="_blank" rel="noopener">http://evilpackage.fatezero.org/</a> 上那 10685 条数据进行统计</p><p>从 2017-05-27 10:38:03 到 2017-05-31 18:24:07，总计 106 个小时内，有 9726 不重复的 ip 安装了 evil package，平均每个小时有 91 个 ip 安装了 evil package。</p><ol><li><p>每个 package 命中排名:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2862 opencv</span><br><span class="line">2834 tkinter</span><br><span class="line">810 mkl</span><br><span class="line">789 python-dev</span><br><span class="line">713 git</span><br><span class="line">683 openssl</span><br><span class="line">535 caffe</span><br><span class="line">328 ffmpeg</span><br><span class="line">224 phantomjs</span><br><span class="line">200 smb</span><br><span class="line">191 vtk</span><br><span class="line">179 pygpu</span><br><span class="line">113 mongodb</span><br><span class="line">70 requirement.txt</span><br><span class="line">56 memcached</span><br><span class="line">31 rabbitmq</span><br><span class="line">15 ftp</span><br><span class="line">14 shadowsock</span><br><span class="line">12 samba</span><br><span class="line">10 proxy</span><br><span class="line">10 hbase</span><br><span class="line">5 zookeeper</span><br></pre></td></tr></table></figure></li><li><p>前 50 个国家命中排名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2507 United States</span><br><span class="line">1667 China</span><br><span class="line">772 India</span><br><span class="line">481 Germany</span><br><span class="line">448 Japan</span><br><span class="line">331 France</span><br><span class="line">319 Republic of Korea</span><br><span class="line">306 United Kingdom</span><br><span class="line">305 Russia</span><br><span class="line">297 Canada</span><br><span class="line">225 Brazil</span><br><span class="line">183 Australia</span><br><span class="line">179 Netherlands</span><br><span class="line">167 Poland</span><br><span class="line">147 Taiwan</span><br><span class="line">129 Italy</span><br><span class="line">127 Israel</span><br><span class="line">126 Spain</span><br><span class="line">106 Singapore</span><br><span class="line">103 Ukraine</span><br><span class="line">89 Hong Kong</span><br><span class="line">87 Switzerland</span><br><span class="line">76 Sweden</span><br><span class="line">74 Turkey</span><br><span class="line">60 Ireland</span><br><span class="line">57 Vietnam</span><br><span class="line">57 Iran</span><br><span class="line">54 Belgium</span><br><span class="line">53 Finland</span><br><span class="line">52 Austria</span><br><span class="line">49 Pakistan</span><br><span class="line">49 Indonesia</span><br><span class="line">47 Argentina</span><br><span class="line">43 New Zealand</span><br><span class="line">42 Mexico</span><br><span class="line">41 Romania</span><br><span class="line">40 Thailand</span><br><span class="line">37 Norway</span><br><span class="line">37 Czechia</span><br><span class="line">31 South Africa</span><br><span class="line">31 Denmark</span><br><span class="line">31 Colombia</span><br><span class="line">29 Portugal</span><br><span class="line">29 Greece</span><br><span class="line">29 Chile</span><br><span class="line">24 Philippines</span><br><span class="line">23 Malaysia</span><br><span class="line">20 Hungary</span><br><span class="line">20 Belarus</span><br><span class="line">19 Nepal</span><br></pre></td></tr></table></figure></li><li><p>每个访问排名 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28 114.255.40.3</span><br><span class="line">25 46.105.249.70</span><br><span class="line">16 54.84.16.79</span><br><span class="line">16 54.237.234.187</span><br><span class="line">16 54.157.41.7</span><br><span class="line">16 54.145.106.255</span><br><span class="line">16 52.90.178.211</span><br><span class="line">13 34.198.151.69</span><br><span class="line">12 52.221.7.193</span><br><span class="line">11 54.235.37.25</span><br><span class="line">10 34.224.47.129</span><br><span class="line">9 172.56.26.43</span><br><span class="line">7 94.153.230.50</span><br><span class="line">7 80.239.169.204</span><br><span class="line">7 73.78.62.6</span><br><span class="line">7 54.87.185.66</span><br><span class="line">7 52.207.13.234</span><br><span class="line">7 113.140.11.125</span><br><span class="line">6 52.55.104.10</span><br><span class="line">6 24.108.0.220</span><br></pre></td></tr></table></figure></li></ol><p>光从这几天来看，在 PyPI 上投放 evilpackage 的效果还是非常不错的，每天都会有大概 2200+ 个独立 ip 进行访问，数据量稍微比之前那位小哥好一点，也就是说，即便是类似的文章发出来，过了一年之后，随意安装 package 的这种情况完全没有改善，可能更严重了。</p><p>那位小哥释放掉所有的 package 之后，我作为一个 “恶意者” 再次使用他之前使用的 <code>git</code>、<code>openssl</code> 名字来统计数据，我作为一个 “恶意者”，被官方勒令删除所有的 package，这些 package 名字再次被释放，我比较好奇下一位 “恶意者” 会是谁，会在 package 里放什么？会是和我一样收集数据，还是直接 <code>rm -rf /</code>，还是勒索。拭目以待。</p><h2 id="0x10-requirements-txt"><a href="#0x10-requirements-txt" class="headerlink" title="0x10 requirements.txt"></a>0x10 requirements.txt</h2><p>一般经常使用 Python 的人都知道 <code>requirements.txt</code> 是整个项目的依赖文件，一般这样使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>不过也有可能一时手速过快，敲打成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requirements.txt</span><br></pre></td></tr></table></figure><p>所以 <code>requirements.txt</code> 也是一个比较好的 evil package 的名字</p><h4 id="诡异的-requirements-txt"><a href="#诡异的-requirements-txt" class="headerlink" title="诡异的 requirements.txt"></a>诡异的 <code>requirements.txt</code></h4><p>在 2017-05-24 19:00 晚上，我尝试在 PyPI 注册上传 <code>requirements.txt</code> 的时候：</p><img src="http://static.fatezero.org/blog/img/package-fishing/upload-requirements-failed.png"><p>嗯，都失败了，但是 <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=repo%3Afate0%2Fcookiecutter-evil-pypackage+requirements.txt&amp;type=Issues" target="_blank" rel="noopener">GitHub Issues</a> 上竟然会有 153 个和 <code>requirements.txt</code> 相关的 Issues：</p><img src="http://static.fatezero.org/blog/img/package-fishing/requirements-txt-show-in-issues.png"><p>我并不怀疑这些 <code>requirements.txt</code> 数据的真实性，因为就没有人知道我尝试上传过 <code>requirements.txt</code>，所以这些数据肯定是真实的。</p><p>PyPI 上也并不存在 <code>requirements.txt</code> 信息，本地尝试安装也失败了，至今仍未明白这种情况为何发生。</p><h4 id="绕过-PyPI-requirements-txt-的限制"><a href="#绕过-PyPI-requirements-txt-的限制" class="headerlink" title="绕过 PyPI requirements.txt 的限制"></a>绕过 PyPI <code>requirements.txt</code> 的限制</h4><p>在 PyPI 账号被删除之后，我还是对 <code>requirements.txt</code> 很好奇，为什么之前 GitHub 上会有记录？能不能绕过 PyPI 的限制？下面简单讲一下如何绕过 PyPI 的限制。</p><p>我们直接查看提交 Package 时，PyPI 对 Package 名字限制的地方：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from: https://github.com/pypa/pypi-legacy/blob/master/webui.py#L2429</span></span><br><span class="line"><span class="meta">@must_tls</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit_pkg_info</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    name = data[<span class="string">'name'</span>]</span><br><span class="line">    version = data[<span class="string">'version'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name.lower() <span class="keyword">in</span> (<span class="string">'requirements.txt'</span>, <span class="string">'rrequirements.txt'</span>,</span><br><span class="line">            <span class="string">'requirements-txt'</span>, <span class="string">'rrequirements-txt'</span>):</span><br><span class="line">        <span class="keyword">raise</span> Forbidden, <span class="string">"Package name '%s' invalid"</span> % name</span><br></pre></td></tr></table></figure></p><p>通过上面的代码，我们可以看到 PyPI 直接硬编码 <code>&#39;requirements.txt&#39;, &#39;rrequirements.txt&#39;, &#39;requirements-txt&#39;, &#39;rrequirements-txt&#39;</code> 禁止用户上传这些文件。</p><p>我们再看看 <code>pip install xxx</code> 的时候，PyPI 是怎么查找 Package 的：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from: https://github.com/pypa/pypi-legacy/blob/master/store.py#L611</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_package</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="string">'''Return names of packages that differ from name only in case.'''</span></span><br><span class="line">    cursor = self.get_cursor()</span><br><span class="line">    sql = <span class="string">'select name from packages where normalize_pep426_name(name)=normalize_pep426_name(%s)'</span></span><br><span class="line">    safe_execute(cursor, sql, (name, ))</span><br><span class="line">    <span class="keyword">return</span> [r[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> cursor.fetchall()]</span><br></pre></td></tr></table></figure></p><p>好吧，直接查找数据库，我们再跟下来看 <code>normalize_pep426_name</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from: https://github.com/pypa/warehouse/blob/master/warehouse/migrations/versions/3af8d0006ba_normalize_runs_of_characters_to_a_.py#L27</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upgrade</span><span class="params">()</span>:</span></span><br><span class="line">    op.execute(</span><br><span class="line">        <span class="string">""" CREATE OR REPLACE FUNCTION normalize_pep426_name(text)</span></span><br><span class="line"><span class="string">            RETURNS text AS</span></span><br><span class="line"><span class="string">            $$</span></span><br><span class="line"><span class="string">                SELECT lower(regexp_replace($1, '(\.|_|-)+', '-', 'ig'))</span></span><br><span class="line"><span class="string">            $$</span></span><br><span class="line"><span class="string">            LANGUAGE SQL</span></span><br><span class="line"><span class="string">            IMMUTABLE</span></span><br><span class="line"><span class="string">            RETURNS NULL ON NULL INPUT;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    )</span><br><span class="line">    op.execute(<span class="string">"REINDEX INDEX project_name_pep426_normalized"</span>)</span><br></pre></td></tr></table></figure></p><p>看到中间那个正则了吧，这也就意味着 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install youtube-dl</span><br><span class="line">pip install youtube_dl</span><br><span class="line">pip install youtube.dl</span><br><span class="line">pip install youtube-_-dl</span><br><span class="line">pip install youtube.-.dl</span><br></pre></td></tr></table></figure></p><p>这几条命令其实都是等价的，都是在安装 <code>youtube_dl</code>, 那么我们就可以很容易的就绕过 PyPI 的限制，直接上传一个 <code>requiremnets--txt</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">twine register dist/requirements--txt-0.1.0.tar.gz</span><br><span class="line">twine upload dist/requirements--txt-0.1.0.tar.gz</span><br></pre></td></tr></table></figure><p>来来来，我们直接尝试 <code>pip install requirements.txt</code>：</p><img src="http://static.fatezero.org/blog/img/package-fishing/install-requirements--txt.png"><p>通过上面的图，我们可以看到 PyPI 已经返回我们的 package url，到了 pip 准备安装这个 package 的时候报错了，所以直接看 pip 代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/pypa/pip/blob/master/pip/index.py#L650</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> version:</span><br><span class="line">    version = egg_info_matches(egg_info, search.supplied, link)</span><br><span class="line"><span class="keyword">if</span> version <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    self._log_skipped_link(</span><br><span class="line">        link, <span class="string">'wrong project name (not %s)'</span> % search.supplied)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>看了代码，也就是没法在 url 中获取 package 的版本号，因为 package 的名字(<code>requirements--txt</code>)和搜索名字(<code>requirements.txt</code>)对不上，我们得找找其他方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/pypa/pip/blob/master/pip/index.py#L626</span></span><br><span class="line"><span class="keyword">if</span> ext == wheel_ext:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        wheel = Wheel(link.filename)</span><br><span class="line">    <span class="keyword">except</span> InvalidWheelFilename:</span><br><span class="line">        self._log_skipped_link(link, <span class="string">'invalid wheel filename'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> canonicalize_name(wheel.name) != search.canonical:</span><br><span class="line">        self._log_skipped_link(</span><br><span class="line">            link, <span class="string">'wrong project name (not %s)'</span> % search.supplied)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wheel.supported(self.valid_tags):</span><br><span class="line">        self._log_skipped_link(</span><br><span class="line">            link, <span class="string">'it is not compatible with this Python'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    version = wheel.version</span><br></pre></td></tr></table></figure><p>看到这里，大家应该也知道了，之前我们一直都是使用 source 的方式提交 package，如果我们直接打包成 wheel，根据上面的代码，就不会再报错了，我们重新打包，再次上传：</p><img src="http://static.fatezero.org/blog/img/package-fishing/upload-requirements-success.png"><p>终于成功了，当然 wheel 安装方式并不能直接执行命令，不过我们可以通过给 <code>requirements.txt</code> 添加一个恶意依赖达到执行任意代码的效果。</p><p>在这里，我就添加了一个名为 <code>ztz</code> 的 source package，用于提醒安装 <code>requirements.txt</code> 的用户</p><img src="http://static.fatezero.org/blog/img/package-fishing/ztz.png"><h2 id="0x11-总结"><a href="#0x11-总结" class="headerlink" title="0x11 总结"></a>0x11 总结</h2><p>最后还是提一下我是怎么被 PyPI 官方发现的，原因非常简单，我之前每个 evil package 都是用同一个 cookiecutter 模版生成，而每个模版的 short desc 都是 <code>just for fun : )</code>，所以在 <a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">PyPI 首页</a> 刷了一排 <code>just for fun : )</code>。就是因为这样简单的理由被发现。</p><p>但是如果，我为每个 evil package 准备不同模版，为每个 evil package 准备文档， 为每个 evil package 准备不同的 PyPI account 上传，每次上传使用不同 ip，在 PyPI 没有审核机制的情况下，是很难将所有的 evil package 一网打尽，只能靠别人 report。</p><p>所以防御方案就完全不可能期待 PyPI 会做什么，只能提升自我对信息安全意识，对 PyPI 上不熟悉的项目一律采取不可信的态度，意识到随意 <code>pip install</code> 就和随意的执行 <code>exe</code> 一样危险。</p><p>想做一件坏事情真不容易，快去看看 <a href="http://evilpackage.fatezero.org/" target="_blank" rel="noopener">http://evilpackage.fatezero.org/</a> 上面有没有你的名字。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;前几天 &lt;code&gt;Samba&lt;/code&gt; 公开了一个远程代码执行的漏洞，然后各种 POC 也随之出现，
&lt;code&gt;exploit-db&lt;/code&gt; 上也有这样一个 Python 版本的 &lt;a href=&quot;https://www.exploit-db.com/exploits/42060/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POC:  Samba 3.5.0 - Remote Code Execution&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解密 RubyEncoder</title>
    <link href="http://blog.fatezero.org/2017/02/26/decrypt-rubyencoder/"/>
    <id>http://blog.fatezero.org/2017/02/26/decrypt-rubyencoder/</id>
    <published>2017-02-26T18:47:24.000Z</published>
    <updated>2018-03-04T14:02:22.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>RubyEncoder 是一款对 Ruby 代码进行混淆加密的软件，因为最近我要破解某个使用 RubyEncoder 加密的 Ruby 程序，所以工作就转移到如何解密 RubyEncoder 加密的程序。</p><a id="more"></a><h2 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h2><p>要想了解 RubyEncoder，那肯定是要去<a href="https://www.rubyencoder.com/trial.html?cm_id=151&amp;action=submit_trial" target="_blank" rel="noopener">官网</a>下载一份试用版，但是无论你怎么填写试用资料：</p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-not-allow-regist.png"><p>我隐约记得 Hacking Team RCS 也用了 RubyEncoder，所以比较幸运的，我从 <a href="https://wikileaks.org/hackingteam/emails/?q=rubyencoder&amp;mfrom=&amp;mto=&amp;title=&amp;notitle=&amp;date=&amp;nofrom=&amp;noto=&amp;count=50&amp;sort=0#searchresult" target="_blank" rel="noopener">Hacking Team 邮件</a> 中找到了一个可以登陆账号密码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Username: alor@hackingteam.it</span><br><span class="line">Password: Oyf4GSy0</span><br></pre></td></tr></table></figure><p>下载到了 RubyEncoder-2.3，并偷偷的使用 Hacking Team 一个 License Key 成功激活了 RubyEncoder</p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-registration.png"><p>先简单试用一下 RubyEncoder</p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-encrypt.png"><p>上图是 RubyEncoder 对某个项目加密的主界面，在这个界面中可以看到，我们可以选择支持的 Ruby 版本。由于因为可以选多个版本号以及 1.8.x 也在支持的版本内，所以可以判定加密后的文件不会是 iseq 或者修改后的 iseq。</p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-lock-options.png"><p>上图是 RubyEncoder 支持的加密选项，可以进行 IP、Domain、MAC、联网、时间、License 限制。其中除了 License 文件之外，其他都是纸老虎，如果 License 文件没有参与对文件的加密，那 License 限制也是纸老虎。不过根据官方文档描述</p><blockquote><p>The algorithm uses an idea of two keys. The first key (Project Id) is stored in the encrypted area of the protected script and is used to decrypt an external license file. The second key (Project Key) is stored in the license file and it is used to decrypt the bytecode from the protected script.</p></blockquote><p>所以如果没有 License 文件是很难将程序跑起来的，不过这篇文章的目的不是怎么样解除这些限制，而是如何解密 RubyEncoder 加密后的 Ruby 代码。</p><p>我们再来看一下 RubyEncoder 的目录结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Loaders</span><br><span class="line">│   ├── Linux</span><br><span class="line">│   │   ├── loader.rb</span><br><span class="line">│   │   ├── my.so</span><br><span class="line">│   │   ├── rgloader.linux.so</span><br><span class="line">│   │   ├── rgloader.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader19.linux.so</span><br><span class="line">│   │   ├── rgloader19.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader192.linux.so</span><br><span class="line">│   │   ├── rgloader192.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader193.linux.so</span><br><span class="line">│   │   ├── rgloader193.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader20.linux.so</span><br><span class="line">│   │   ├── rgloader20.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader21.linux.so</span><br><span class="line">│   │   ├── rgloader21.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader22.linux.so</span><br><span class="line">│   │   ├── rgloader22.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader23.linux.so</span><br><span class="line">│   │   └── rgloader23.linux.x86_64.so</span><br><span class="line">│   ├── Mac\ OS\ X // 省略 ..</span><br><span class="line">│   ├── MinGW // 省略 ...</span><br><span class="line">│   └── Windows // 省略 ...</span><br><span class="line">├── RubyEncoder</span><br><span class="line">├── license.txt</span><br><span class="line">├── licgen</span><br><span class="line">├── rgencoder</span><br><span class="line">├── rginfo</span><br><span class="line">├── rubyencoder18.bundle</span><br><span class="line">├── rubyencoder19.bundle</span><br><span class="line">├── rubyencoder192.bundle</span><br><span class="line">├── rubyencoder20.bundle</span><br><span class="line">├── rubyencoder21.bundle</span><br><span class="line">├── rubyencoder22.bundle</span><br><span class="line">├── rubyencoder23.bundle</span><br><span class="line">└── update</span><br></pre></td></tr></table></figure><p>简单看了一下 <code>rubyencoder*.bundle</code> 文件，应该是直接把整个 Ruby 给打包进来了，应该是加密的过程中需要 Ruby 的一些功能，不过我并不是特别关注加密过程，所以直接看 <code>Loaders</code> 目录下的文件，这个目录下包含了所支持的平台下、Ruby 版本的解密 so 文件。</p><p>当然除了需要下载 RubyEncoder 程序，还需要找一找有没有前辈已经搞定这个程序的，google 一番之后找到 <a href="https://www.ruby-forum.com/topic/168409#741854" target="_blank" rel="noopener">I found way to protect Source Code! :)</a> 这个帖子。</p><p>这个帖子的思路是：</p><ol><li>将 <code>ruby_exec</code> 修改成 <code>ruby_exic</code> 以便获得 AST</li><li>使用修改后的 <code>ParseTree</code> 将 Ruby 内部的 AST 转成 sexp</li><li>使用 <code>ruby2ruby</code> 将 sexp 转成 Ruby 代码</li></ol><p>不过这个帖子当时使用的是 <code>Ruby 1.8.7</code>，也就是当时 Ruby 还是构建完 AST 之后就直接执行，1.9.x 后的 Ruby 需要编译成 iseq。另外由于 <code>Ruby 1.8</code> 和 <code>Ruby 2.x</code> 有很大的不同，上面的 <code>ParseTree</code> 在 Ruby 使用 iseq 之后就再也不能使用了。所以上面的方法在 <code>Ruby 2.x</code> 中行不通了。</p><h2 id="0x02-简单逆向"><a href="#0x02-简单逆向" class="headerlink" title="0x02 简单逆向"></a>0x02 简单逆向</h2><p>我们使用 RubyEncoder 对以下代码进行加密</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">puts <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure><p>得到下面加密后的代码</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RubyEncoder v2.3.0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.respond_to?(<span class="symbol">:RGLoader_load</span>,<span class="symbol">:include_private</span>) <span class="keyword">then</span> _d = _d<span class="number">0</span> = File.expand_path(File.dirname(__FILE_<span class="number">_</span>)); <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span> _f = _d + <span class="string">'/rgloader/loader.rb'</span>; <span class="keyword">break</span> <span class="keyword">if</span> File.exist?(_f); _d1 = File.dirname(_d); <span class="keyword">if</span> _d1 == _d <span class="keyword">then</span> raise <span class="string">"Ruby script '"</span>+__FILE_<span class="number">_</span>+<span class="string">"' is protected by RubyEncoder and requires a RubyEncoder loader to be installed. Please visit the http://www.rubyencoder.com/loaders/ RubyEncoder web site to download the required loader and unpack it into '"</span>+_d<span class="number">0</span>+<span class="string">"/rgloader/' directory in order to run this protected file."</span>; exit; <span class="keyword">else</span> _d = _d1; <span class="keyword">end</span>; <span class="keyword">end</span>; <span class="keyword">require</span> _f; <span class="keyword">end</span>; RGLoader_load(<span class="string">'AAIAAAAEgAAAAIAAAAAA/0R/d65ujW/5OhgbeUf0jhTRfPXr0uXNuC7gK8ycmR473fPEIlsgFP1/KF+CYBVbQy4xoLUhBFtBlYwH2aDOtcTasNDJPMDtoEgRuRdFRDgJoX1oKhrm0ZKm9OdIM6MbXRc/fh4n984TVew76DqbxQTplVhMxzOCp/mKgLU+shxBFAAAAGAAAAA7Nu8kj4NtO8BQECP2bW1TonmX+NADX/HETWg1j5fvbB8gptZ38XCzJxOccT2CTUsTT8GFq67RttUD7IR/xN2FBCWKMZ1BlGYVlhSmSUc6hS5RfglTuyvdVdjnsgcnkTAVAAAAYAAAAIrxSQfPHlMc89mPBUXSQ6vxmM9yoDu7Rf+O87mTUW4L0VuAWkIhvFUBxXRVm6Q7kkWHg7D7cdIwwA62+ewy91l56aMIQujAKZrVn4T1zreKf1QdGvK+QGY4rIpGEmTBhBYAAABoAAAADdYzBFrSrrZ4o9uzaoq+Yxjk44lzEa+/oxXM7fmbm8gJ1W3MlUZyPqIjW01KUb6nZjWIAz629+KP5nL/GMP0BClkOjpXQ9b95R/qvlDzuP7UZHPeqaIJq2yMN7Mh9WROfAhLlhmK86AXAAAAcAAAAGgSDy/YvPJQsKnC+JvR+ITlVdWPGodUNT10I0CPLu9d81hMtEL9hU4t9yVfBcS2BWDqBg3ahhUTvqNYxwvX8NCHmZU4LQmdd3dJneWJzGy6VbAQeVDNeaJl8/SPdRn1VXaspqWGYFn1cXqp7rhHLUcAAAAA'</span>);</span><br></pre></td></tr></table></figure><p>可以看到最关键的函数就是 <code>RGLoader_load</code>，所以直接将 <code>rgloader22.linux.x86_64.so</code> 丢进 IDA，找到 <code>RGLoader_load</code> 的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">rgloader_load</span><span class="params">(<span class="keyword">int</span> a1, _DWORD *a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略 ...</span></span><br><span class="line">    v126 = v124;</span><br><span class="line">    v127 = _decode_node(v124);</span><br><span class="line">    mstream_close(v126);</span><br><span class="line">    ruby_xfree(v23);</span><br><span class="line">    <span class="keyword">if</span> ( !v127 || decoder_error )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_243;</span><br><span class="line">    v128 = *(_DWORD *)(rb_thread_current() + <span class="number">16</span>);</span><br><span class="line">    v210 = *(_DWORD *)(v128 + <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> ( a1 == rgloader_module )</span><br><span class="line">        *(_DWORD *)(v128 + <span class="number">60</span>) = *(_DWORD *)(*(_DWORD *)(v128 + <span class="number">24</span>) + <span class="number">56</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *(_DWORD *)(v128 + <span class="number">60</span>) = *(_DWORD *)(*(_DWORD *)(v128 + <span class="number">24</span>) + <span class="number">16</span>);</span><br><span class="line">    v129 = (<span class="keyword">char</span> *)rg_current_realfilepath();</span><br><span class="line">    v130 = rb_sourcefile();</span><br><span class="line">    v131 = rb_str_new_cstr(v130);</span><br><span class="line">    v132 = rb_str_new_static(<span class="string">"&lt;encoded&gt;"</span>, <span class="number">9</span>);</span><br><span class="line">    v133 = rb_iseq_new(v127, v132, v131, v129, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    result = rb_iseq_eval(v133);</span><br><span class="line">    *(_DWORD *)(v128 + <span class="number">60</span>) = v210;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，事实上，RubyEncoder 就算是到了 2.3 版本，还是和上面那个帖子所说的一样：</p><blockquote><p>It turns out, that RubyEncoder uses following scheme: modifiedRuby-1.8.7 interpreter,that stores encoded AST nodes along with encoding/restriction options,while rgloader simply decodes it back to AST and executes.</p></blockquote><p>只不过这里多了一步 <code>v133 = rb_iseq_new(v127, v132, v131, v129, 0, 0);</code> 将 AST 编译成 iseq。</p><p>我们可以通过 hook <code>rb_iseq_new</code> 拿到 AST，hook <code>rb_iseq_eval</code> 拿到 iseq。</p><p>下面我们修改 Ruby 代码将 AST 以及 iseq dump 出来。</p><ol><li><p>one byte hack</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp rgloader22.linux.x86_64.so bak.so</span><br><span class="line">sed <span class="string">'s/rb_iseq_eval/rb_iseq_evax/g'</span> rgloader22.linux.x86_64.so &gt; tmp.so</span><br><span class="line">sed <span class="string">'s/rb_iseq_new/rb_iseq_nex/g'</span> tmp.so &gt; rgloader22.linux.x86_64.so</span><br></pre></td></tr></table></figure></li><li><p>在 <code>iseq.c</code> 中实现 <code>rb_iseq_nex</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VALUE</span><br><span class="line">rb_iseq_nex(NODE *node, VALUE name, VALUE path, VALUE absolute_path,</span><br><span class="line">            VALUE parent, <span class="keyword">enum</span> iseq_type type)</span><br><span class="line">&#123;</span><br><span class="line">    rb_io_write(rb_stdout, rb_parser_dump_tree(node, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> rb_iseq_new(node, name, path, absolute_path, parent, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 <code>vm.c</code> 中实现 <code>rb_iseq_evax</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VALUE</span><br><span class="line">rb_iseq_evax(VALUE iseqval)</span><br><span class="line">&#123;</span><br><span class="line">    rb_io_write(rb_stdout, rb_iseq_disasm(iseqval));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>结果:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###########################################################</span><br><span class="line">## Do NOT use this node dump for any purpose other than  ##</span><br><span class="line">## debug and research.  Compatibility is not guaranteed. ##</span><br><span class="line">###########################################################</span><br><span class="line"></span><br><span class="line"># @ NODE_SCOPE (line: 1)</span><br><span class="line"># +- nd_tbl: (empty)</span><br><span class="line"># +- nd_args:</span><br><span class="line"># |   (null node)</span><br><span class="line"># +- nd_body:</span><br><span class="line">#     @ NODE_FCALL (line: 1)</span><br><span class="line">#     +- nd_mid: :puts</span><br><span class="line">#     +- nd_args:</span><br><span class="line">#         @ NODE_ARRAY (line: 1)</span><br><span class="line">#         +- nd_alen: 1</span><br><span class="line">#         +- nd_head:</span><br><span class="line">#         |   @ NODE_STR (line: 1)</span><br><span class="line">#         |   +- nd_lit: &quot;Hello World!&quot;</span><br><span class="line">#         +- nd_next:</span><br><span class="line">#             (null node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">== disasm: &lt;RubyVM::InstructionSequence:&lt;encoded&gt;@./ruby-2.2.6/hello.rb&gt;</span><br><span class="line">0000 trace            1                                               (   1)</span><br><span class="line">0002 putself</span><br><span class="line">0003 putstring        &quot;Hello World!&quot;</span><br><span class="line">0005 opt_send_without_block &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span><br><span class="line">0007 leave</span><br></pre></td></tr></table></figure></p><p>上面就是 dump 出来的 AST 和 iseq，不过这些离我们的最终目标还有一点点距离。</p><h2 id="0x03-生成代码"><a href="#0x03-生成代码" class="headerlink" title="0x03 生成代码"></a>0x03 生成代码</h2><p>由于之前的 <code>parsetree</code> 已经不能再使用了，google了一番之后，也没有找到现成的，之前的打算是写一个类似 Python 的 uncompyle 之类的东西, 解析 iseq 结构、构建 AST、生成代码，不过后面发现自己实在没那么多时间，于是就偷懒直接从 Ruby 的 AST 直接生成代码。</p><p>对照着 Ruby 的 <code>node.c</code>、<code>parse.y</code>、<code>compile.c</code> 就可以写出</p><p><a href="https://gist.github.com/fate0/a1851bb39efe177bec20dbcd4445f6f3" target="_blank" rel="noopener">node2ruby.c</a></p><p>试试看这个代码反编译的效果，测试文件 <a href="https://github.com/ruby/ruby/blob/ruby_2_2/lib/net/http.rb" target="_blank" rel="noopener">http.rb</a></p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/decrypt-result.png"><p>感觉效果还是差强人意，代码算是可以能看的，但是想要执行起来还要继续对代码进行修改(因为<a href="https://gist.github.com/fate0/a1851bb39efe177bec20dbcd4445f6f3" target="_blank" rel="noopener">node2ruby.c</a> 还有挺多地方没考虑到的) </p><p>总的来说，Ruby 写的代码还是比较友好的，像我这样的新手都能很快上手，嗯，除了有些小错误外，顺手给 Ruby 提交了两 PR：</p><ul><li><a href="https://github.com/ruby/ruby/pull/1528" target="_blank" rel="noopener">node.c: fix NODE_OP_ASGN1 operator</a></li><li><a href="https://github.com/ruby/ruby/pull/1529" target="_blank" rel="noopener">node.c: fix nd_ainfo-&gt;kw_rest_arg</a></li></ul><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>写 <a href="https://gist.github.com/fate0/a1851bb39efe177bec20dbcd4445f6f3" target="_blank" rel="noopener">node2ruby.c</a> 的时候就觉得如果不是特别熟悉 Ruby 的话，有些比较奇怪的语句还是想不到的。</p><p>对了，还记得我们上面所说的，如果没有 License 文件，就很难将程序跑起来么？嗯，我要解密的 Ruby 代码就是必须要 License 文件的，而且我还没有 License。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;RubyEncoder 是一款对 Ruby 代码进行混淆加密的软件，因为最近我要破解某个使用 RubyEncoder 加密的 Ruby 程序，
所以工作就转移到如何解密 RubyEncoder 加密的程序。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阴阳师：一个非酋的逆向旅程</title>
    <link href="http://blog.fatezero.org/2017/01/14/decrypt-onmyoji/"/>
    <id>http://blog.fatezero.org/2017/01/14/decrypt-onmyoji/</id>
    <published>2017-01-14T12:15:11.000Z</published>
    <updated>2018-03-04T14:02:22.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>为了验证这个游戏到底有没有 SSR</p><a id="more"></a><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p><a href="https://www.baidu.com/s?wd=阴阳师：一个非酋的逆向旅程" target="_blank" rel="noopener">阴阳师:一个非酋的逆向旅程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;为了验证这个游戏到底有没有 SSR&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Komm, süsser Tod</title>
    <link href="http://blog.fatezero.org/2016/12/21/Komm-susser-Tod/"/>
    <id>http://blog.fatezero.org/2016/12/21/Komm-susser-Tod/</id>
    <published>2016-12-21T22:53:27.000Z</published>
    <updated>2018-03-04T14:02:22.363Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的意义在于测试这个主题所支持的功能</p><a id="more"></a><h2 id="测试-MarkDown-功能"><a href="#测试-MarkDown-功能" class="headerlink" title="测试 MarkDown 功能"></a>测试 MarkDown 功能</h2><h4 id="0x1-表格"><a href="#0x1-表格" class="headerlink" title="0x1. 表格"></a>0x1. 表格</h4><table><thead><tr><th style="text-align:left">靠左表头</th><th style="text-align:center">居中表头</th><th style="text-align:right">靠右表头</th></tr></thead><tbody><tr><td style="text-align:left"><code>content</code></td><td style="text-align:center">内容</td><td style="text-align:right">$a=1$</td></tr><tr><td style="text-align:left"><em>内容</em></td><td style="text-align:center">$a^3$</td><td style="text-align:right"><strong>内容</strong></td></tr></tbody></table><h4 id="0x2-代码"><a href="#0x2-代码" class="headerlink" title="0x2. 代码"></a>0x2. 代码</h4><p>这里是代码块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><p>这里是行内代码 <code>print(&quot;hello world&quot;)</code></p><h4 id="0x3-引用"><a href="#0x3-引用" class="headerlink" title="0x3. 引用"></a>0x3. 引用</h4><blockquote><p>这里是引用第二行引用</p></blockquote><h4 id="0x4-链接"><a href="#0x4-链接" class="headerlink" title="0x4. 链接"></a>0x4. 链接</h4><p><a href="http://blog.fatezero.org">我的博客</a><a href="http://wiki.fatezero.org" target="_blank" rel="noopener">我的wiki</a></p><h4 id="0x5-图片"><a href="#0x5-图片" class="headerlink" title="0x5. 图片"></a>0x5. 图片</h4><p><img src="https://octodex.github.com/images/privateinvestocat.jpg" alt="privateinvestocat"></p><h2 id="测试-mathjax"><a href="#测试-mathjax" class="headerlink" title="测试 mathjax"></a>测试 mathjax</h2><p>这里是数学公式块</p>$$        \begin{matrix}        1 & x & x^2 \\        1 & y & y^2 \\        1 & z & z^2 \\        \end{matrix}$$<p>这个是行内数学公式 $\sqrt[4]{\frac xy}$</p><h2 id="测试-Hexo-功能"><a href="#测试-Hexo-功能" class="headerlink" title="测试 Hexo 功能"></a>测试 Hexo 功能</h2><h4 id="0x1-img"><a href="#0x1-img" class="headerlink" title="0x1. img"></a>0x1. img</h4><img src="https://octodex.github.com/images/privateinvestocat.jpg" width="200" height="200"><p>一般使用 Hexo 内的图片 tag, 因为可以调整图片大小</p><h4 id="0x2-raw"><a href="#0x2-raw" class="headerlink" title="0x2. raw"></a>0x2. raw</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><h4 id="0x3-主题-tip"><a href="#0x3-主题-tip" class="headerlink" title="0x3. 主题 tip"></a>0x3. 主题 tip</h4><div class="tip">    这个是主题带的 tip</div><h4 id="0x4-iframe"><a href="#0x4-iframe" class="headerlink" title="0x4. iframe"></a>0x4. iframe</h4><iframe src="//www.fatezero.org" width="500" height="86" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章的意义在于测试这个主题所支持的功能&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
