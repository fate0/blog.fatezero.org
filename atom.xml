<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fate0</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.fatezero.org/"/>
  <updated>2017-02-27T14:33:51.052Z</updated>
  <id>http://blog.fatezero.org/</id>
  
  <author>
    <name>fate0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解密 RubyEncoder</title>
    <link href="http://blog.fatezero.org/2017/02/26/decrypt-rubyencoder/"/>
    <id>http://blog.fatezero.org/2017/02/26/decrypt-rubyencoder/</id>
    <published>2017-02-26T18:47:24.000Z</published>
    <updated>2017-02-27T14:33:51.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>RubyEncoder 是一款对 Ruby 代码进行混淆加密的软件，因为最近我要破解某个使用 RubyEncoder 加密的 Ruby 程序，
所以工作就转移到如何解密 RubyEncoder 加密的程序。</p>
<a id="more"></a>
<h2 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h2><p>要想了解 RubyEncoder，那肯定是要去<a href="https://www.rubyencoder.com/trial.html?cm_id=151&amp;action=submit_trial" target="_blank" rel="external">官网</a>下载一份试用版，但是无论你怎么填写试用资料：</p>
<img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-not-allow-regist.png">
<p>我隐约记得 Hacking Team RCS 也用了 RubyEncoder，所以比较幸运的，
我从 <a href="https://wikileaks.org/hackingteam/emails/?q=rubyencoder&amp;mfrom=&amp;mto=&amp;title=&amp;notitle=&amp;date=&amp;nofrom=&amp;noto=&amp;count=50&amp;sort=0#searchresult" target="_blank" rel="external">Hacking Team 邮件</a> 中找到了一个可以登陆账号密码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Username: alor@hackingteam.it</div><div class="line">Password: Oyf4GSy0</div></pre></td></tr></table></figure>
<p>下载到了 RubyEncoder-2.3，并偷偷的使用 Hacking Team 一个 License Key 成功激活了 RubyEncoder</p>
<img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-registration.png">
<p>先简单试用一下 RubyEncoder</p>
<img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-encrypt.png">
<p>上图是 RubyEncoder 对某个项目加密的主界面，在这个界面中可以看到，我们可以选择支持的 Ruby 版本。
由于因为可以选多个版本号以及 1.8.x 也在支持的版本内，所以可以判定加密后的文件不会是 iseq 或者修改后的 iseq。</p>
<img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-lock-options.png">
<p>上图是 RubyEncoder 支持的加密选项，可以进行 IP、Domain、MAC、联网、时间、License 限制。其中除了 License 文件之外，其他都是纸老虎，
如果 License 文件没有参与对文件的加密，那 License 限制也是纸老虎。不过根据官方文档描述</p>
<blockquote>
<p>The algorithm uses an idea of two keys. The first key (Project Id) is stored in the encrypted area of the protected script and is used to decrypt an external license file. The second key (Project Key) is stored in the license file and it is used to decrypt the bytecode from the protected script.</p>
</blockquote>
<p>所以如果没有 License 文件是很难将程序跑起来的，不过这篇文章的目的不是怎么样解除这些限制，而是如何解密 RubyEncoder 加密后的 Ruby 代码。</p>
<p>我们再来看一下 RubyEncoder 的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.</div><div class="line">├── Loaders</div><div class="line">│   ├── Linux</div><div class="line">│   │   ├── loader.rb</div><div class="line">│   │   ├── my.so</div><div class="line">│   │   ├── rgloader.linux.so</div><div class="line">│   │   ├── rgloader.linux.x86_64.so</div><div class="line">│   │   ├── rgloader19.linux.so</div><div class="line">│   │   ├── rgloader19.linux.x86_64.so</div><div class="line">│   │   ├── rgloader192.linux.so</div><div class="line">│   │   ├── rgloader192.linux.x86_64.so</div><div class="line">│   │   ├── rgloader193.linux.so</div><div class="line">│   │   ├── rgloader193.linux.x86_64.so</div><div class="line">│   │   ├── rgloader20.linux.so</div><div class="line">│   │   ├── rgloader20.linux.x86_64.so</div><div class="line">│   │   ├── rgloader21.linux.so</div><div class="line">│   │   ├── rgloader21.linux.x86_64.so</div><div class="line">│   │   ├── rgloader22.linux.so</div><div class="line">│   │   ├── rgloader22.linux.x86_64.so</div><div class="line">│   │   ├── rgloader23.linux.so</div><div class="line">│   │   └── rgloader23.linux.x86_64.so</div><div class="line">│   ├── Mac\ OS\ X // 省略 ..</div><div class="line">│   ├── MinGW // 省略 ...</div><div class="line">│   └── Windows // 省略 ...</div><div class="line">├── RubyEncoder</div><div class="line">├── license.txt</div><div class="line">├── licgen</div><div class="line">├── rgencoder</div><div class="line">├── rginfo</div><div class="line">├── rubyencoder18.bundle</div><div class="line">├── rubyencoder19.bundle</div><div class="line">├── rubyencoder192.bundle</div><div class="line">├── rubyencoder20.bundle</div><div class="line">├── rubyencoder21.bundle</div><div class="line">├── rubyencoder22.bundle</div><div class="line">├── rubyencoder23.bundle</div><div class="line">└── update</div></pre></td></tr></table></figure>
<p>简单看了一下 <code>rubyencoder*.bundle</code> 文件，应该是直接把整个 Ruby 给打包进来了，应该是加密的过程中需要 Ruby 的一些功能，
不过我并不是特别关注加密过程，所以直接看 <code>Loaders</code> 目录下的文件，这个目录下包含了所支持的平台下、Ruby 版本的解密 so 文件。</p>
<p>当然除了需要下载 RubyEncoder 程序，还需要找一找有没有前辈已经搞定这个程序的，
google 一番之后找到 <a href="https://www.ruby-forum.com/topic/168409#741854" target="_blank" rel="external">I found way to protect Source Code! :)</a> 这个帖子。</p>
<p>这个帖子的思路是：</p>
<ol>
<li>将 <code>ruby_exec</code> 修改成 <code>ruby_exic</code> 以便获得 AST</li>
<li>使用修改后的 <code>ParseTree</code> 将 Ruby 内部的 AST 转成 sexp</li>
<li>使用 <code>ruby2ruby</code> 将 sexp 转成 Ruby 代码</li>
</ol>
<p>不过这个帖子当时使用的是 <code>Ruby 1.8.7</code>，也就是当时 Ruby 还是构建完 AST 之后就直接执行，1.9.x 后的 Ruby 需要编译成 iseq。
另外由于 <code>Ruby 1.8</code> 和 <code>Ruby 2.x</code> 有很大的不同，上面的 <code>ParseTree</code> 在 Ruby 使用 iseq 之后就再也不能使用了。
所以上面的方法在 <code>Ruby 2.x</code> 中行不通了。</p>
<h2 id="0x02-简单逆向"><a href="#0x02-简单逆向" class="headerlink" title="0x02 简单逆向"></a>0x02 简单逆向</h2><p>我们使用 RubyEncoder 对以下代码进行加密</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line">puts <span class="string">"Hello World!"</span></div></pre></td></tr></table></figure>
<p>得到下面加密后的代码</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><div class="line"><span class="comment"># RubyEncoder v2.3.0</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.respond_to?(<span class="symbol">:RGLoader_load</span>,<span class="symbol">:include_private</span>) <span class="keyword">then</span> _d = _d<span class="number">0</span> = File.expand_path(File.dirname(__FILE_<span class="number">_</span>)); <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span> _f = _d + <span class="string">'/rgloader/loader.rb'</span>; <span class="keyword">break</span> <span class="keyword">if</span> File.exist?(_f); _d1 = File.dirname(_d); <span class="keyword">if</span> _d1 == _d <span class="keyword">then</span> raise <span class="string">"Ruby script '"</span>+__FILE_<span class="number">_</span>+<span class="string">"' is protected by RubyEncoder and requires a RubyEncoder loader to be installed. Please visit the http://www.rubyencoder.com/loaders/ RubyEncoder web site to download the required loader and unpack it into '"</span>+_d<span class="number">0</span>+<span class="string">"/rgloader/' directory in order to run this protected file."</span>; exit; <span class="keyword">else</span> _d = _d1; <span class="keyword">end</span>; <span class="keyword">end</span>; <span class="keyword">require</span> _f; <span class="keyword">end</span>; RGLoader_load(<span class="string">'AAIAAAAEgAAAAIAAAAAA/0R/d65ujW/5OhgbeUf0jhTRfPXr0uXNuC7gK8ycmR473fPEIlsgFP1/KF+CYBVbQy4xoLUhBFtBlYwH2aDOtcTasNDJPMDtoEgRuRdFRDgJoX1oKhrm0ZKm9OdIM6MbXRc/fh4n984TVew76DqbxQTplVhMxzOCp/mKgLU+shxBFAAAAGAAAAA7Nu8kj4NtO8BQECP2bW1TonmX+NADX/HETWg1j5fvbB8gptZ38XCzJxOccT2CTUsTT8GFq67RttUD7IR/xN2FBCWKMZ1BlGYVlhSmSUc6hS5RfglTuyvdVdjnsgcnkTAVAAAAYAAAAIrxSQfPHlMc89mPBUXSQ6vxmM9yoDu7Rf+O87mTUW4L0VuAWkIhvFUBxXRVm6Q7kkWHg7D7cdIwwA62+ewy91l56aMIQujAKZrVn4T1zreKf1QdGvK+QGY4rIpGEmTBhBYAAABoAAAADdYzBFrSrrZ4o9uzaoq+Yxjk44lzEa+/oxXM7fmbm8gJ1W3MlUZyPqIjW01KUb6nZjWIAz629+KP5nL/GMP0BClkOjpXQ9b95R/qvlDzuP7UZHPeqaIJq2yMN7Mh9WROfAhLlhmK86AXAAAAcAAAAGgSDy/YvPJQsKnC+JvR+ITlVdWPGodUNT10I0CPLu9d81hMtEL9hU4t9yVfBcS2BWDqBg3ahhUTvqNYxwvX8NCHmZU4LQmdd3dJneWJzGy6VbAQeVDNeaJl8/SPdRn1VXaspqWGYFn1cXqp7rhHLUcAAAAA'</span>);</div></pre></td></tr></table></figure>
<p>可以看到最关键的函数就是 <code>RGLoader_load</code>，所以直接将 <code>rgloader22.linux.x86_64.so</code> 丢进 IDA，找到 <code>RGLoader_load</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">rgloader_load</span><span class="params">(<span class="keyword">int</span> a1, _DWORD *a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span> </span>&#123;</div><div class="line">    <span class="comment">// 省略 ...</span></div><div class="line">    v126 = v124;</div><div class="line">    v127 = _decode_node(v124);</div><div class="line">    mstream_close(v126);</div><div class="line">    ruby_xfree(v23);</div><div class="line">    <span class="keyword">if</span> ( !v127 || decoder_error )</div><div class="line">        <span class="keyword">goto</span> LABEL_243;</div><div class="line">    v128 = *(_DWORD *)(rb_thread_current() + <span class="number">16</span>);</div><div class="line">    v210 = *(_DWORD *)(v128 + <span class="number">60</span>);</div><div class="line">    <span class="keyword">if</span> ( a1 == rgloader_module )</div><div class="line">        *(_DWORD *)(v128 + <span class="number">60</span>) = *(_DWORD *)(*(_DWORD *)(v128 + <span class="number">24</span>) + <span class="number">56</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        *(_DWORD *)(v128 + <span class="number">60</span>) = *(_DWORD *)(*(_DWORD *)(v128 + <span class="number">24</span>) + <span class="number">16</span>);</div><div class="line">    v129 = (<span class="keyword">char</span> *)rg_current_realfilepath();</div><div class="line">    v130 = rb_sourcefile();</div><div class="line">    v131 = rb_str_new_cstr(v130);</div><div class="line">    v132 = rb_str_new_static(<span class="string">"&lt;encoded&gt;"</span>, <span class="number">9</span>);</div><div class="line">    v133 = rb_iseq_new(v127, v132, v131, v129, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    result = rb_iseq_eval(v133);</div><div class="line">    *(_DWORD *)(v128 + <span class="number">60</span>) = v210;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嗯，事实上，RubyEncoder 就算是到了 2.3 版本，还是和上面那个帖子所说的一样：</p>
<blockquote>
<p>It turns out, that RubyEncoder uses following scheme: modified
Ruby-1.8.7 interpreter,
that stores encoded AST nodes along with encoding/restriction options,
while rgloader simply decodes it back to AST and executes.</p>
</blockquote>
<p>只不过这里多了一步 <code>v133 = rb_iseq_new(v127, v132, v131, v129, 0, 0);</code> 将 AST 编译成 iseq。</p>
<p>我们可以通过 hook <code>rb_iseq_new</code> 拿到 AST，hook <code>rb_iseq_eval</code> 拿到 iseq。</p>
<p>下面我们修改 Ruby 代码将 AST 以及 iseq dump 出来。</p>
<ol>
<li><p>one byte hack</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">cp rgloader22.linux.x86_64.so bak.so</div><div class="line">sed <span class="string">'s/rb_iseq_eval/rb_iseq_evax/g'</span> rgloader22.linux.x86_64.so &gt; tmp.so</div><div class="line">sed <span class="string">'s/rb_iseq_new/rb_iseq_nex/g'</span> tmp.so &gt; rgloader22.linux.x86_64.so</div></pre></td></tr></table></figure>
</li>
<li><p>在 <code>iseq.c</code> 中实现 <code>rb_iseq_nex</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function">VALUE</span></div><div class="line"><span class="title">rb_iseq_nex</span><span class="params">(NODE *node, VALUE name, VALUE path, VALUE absolute_path,</span></div><div class="line">            VALUE parent, <span class="keyword">enum</span> iseq_type type)</div><div class="line">&#123;</div><div class="line">    rb_io_write(rb_stdout, rb_parser_dump_tree(node, <span class="number">0</span>));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</div><div class="line">    <span class="keyword">return</span> rb_iseq_new(node, name, path, absolute_path, parent, type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实现 <code>vm.c</code> 中实现 <code>rb_iseq_evax</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function">VALUE</span></div><div class="line"><span class="title">rb_iseq_evax</span><span class="params">(VALUE iseqval)</span></div><div class="line">&#123;</div><div class="line">    rb_io_write(rb_stdout, rb_iseq_disasm(iseqval));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>结果:
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">###########################################################</div><div class="line">## Do NOT use this node dump for any purpose other than  ##</div><div class="line">## debug and research.  Compatibility is not guaranteed. ##</div><div class="line">###########################################################</div><div class="line"></div><div class="line"># @ NODE_SCOPE (line: 1)</div><div class="line"># +- nd_tbl: (empty)</div><div class="line"># +- nd_args:</div><div class="line"># |   (null node)</div><div class="line"># +- nd_body:</div><div class="line">#     @ NODE_FCALL (line: 1)</div><div class="line">#     +- nd_mid: :puts</div><div class="line">#     +- nd_args:</div><div class="line">#         @ NODE_ARRAY (line: 1)</div><div class="line">#         +- nd_alen: 1</div><div class="line">#         +- nd_head:</div><div class="line">#         |   @ NODE_STR (line: 1)</div><div class="line">#         |   +- nd_lit: &quot;Hello World!&quot;</div><div class="line">#         +- nd_next:</div><div class="line">#             (null node)</div><div class="line"></div><div class="line"></div><div class="line">== disasm: &lt;RubyVM::InstructionSequence:&lt;encoded&gt;@./ruby-2.2.6/hello.rb&gt;</div><div class="line">0000 trace            1                                               (   1)</div><div class="line">0002 putself</div><div class="line">0003 putstring        &quot;Hello World!&quot;</div><div class="line">0005 opt_send_without_block &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</div><div class="line">0007 leave</div></pre></td></tr></table></figure></p>
<p>上面就是 dump 出来的 AST 和 iseq，不过这些离我们的最终目标还有一点点距离。</p>
<h2 id="0x03-生成代码"><a href="#0x03-生成代码" class="headerlink" title="0x03 生成代码"></a>0x03 生成代码</h2><p>由于之前的 <code>parsetree</code> 已经不能再使用了，google了一番之后，也没有找到现成的，
之前的打算是写一个类似 Python 的 uncompyle 之类的东西, 解析 iseq 结构、构建 AST、生成代码，
不过后面发现自己实在没那么多时间，于是就偷懒直接从 Ruby 的 AST 直接生成代码。</p>
<p>对照着 Ruby 的 <code>node.c</code>、<code>parse.y</code>、<code>compile.c</code> 就可以写出</p>
<p><a href="https://gist.github.com/fate0/a1851bb39efe177bec20dbcd4445f6f3" target="_blank" rel="external">node2ruby.c</a></p>
<p>试试看这个代码反编译的效果，测试文件 <a href="https://github.com/ruby/ruby/blob/ruby_2_2/lib/net/http.rb" target="_blank" rel="external">http.rb</a></p>
<img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/decrypt-result.png">
<p>感觉效果还是差强人意，代码算是可以能看的，但是想要执行起来还要继续仅需对代码进行修改(因为<a href="https://gist.github.com/fate0/a1851bb39efe177bec20dbcd4445f6f3" target="_blank" rel="external">node2ruby.c</a> 还有挺多地方没考虑到的) </p>
<p>总的来说，Ruby 写的代码还是比较友好的，像我这样的新手都能很快上手，嗯，除了有些小错误外，顺手提交了两 PR</p>
<ul>
<li><a href="https://github.com/ruby/ruby/pull/1528" target="_blank" rel="external">node.c: fix NODE_OP_ASGN1 operator</a></li>
<li><a href="https://github.com/ruby/ruby/pull/1529" target="_blank" rel="external">node.c: fix nd_ainfo-&gt;kw_rest_arg</a></li>
</ul>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>写 <a href="https://gist.github.com/fate0/a1851bb39efe177bec20dbcd4445f6f3" target="_blank" rel="external">node2ruby.c</a> 的时候就觉得如果不是特别熟悉 Ruby 的话，有些比较奇怪的语句还是想不到的。</p>
<p>对了，还记得我们上面所说的，如果没有 License 文件，就很难将程序跑起来么？
嗯，我要解密的 Ruby 代码就是必须要 License 文件的，而且我还没有 License。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;RubyEncoder 是一款对 Ruby 代码进行混淆加密的软件，因为最近我要破解某个使用 RubyEncoder 加密的 Ruby 程序，
所以工作就转移到如何解密 RubyEncoder 加密的程序。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阴阳师：一个非酋的逆向旅程(TODO)</title>
    <link href="http://blog.fatezero.org/2017/01/14/decrypt-onmyoji/"/>
    <id>http://blog.fatezero.org/2017/01/14/decrypt-onmyoji/</id>
    <published>2017-01-14T12:15:11.000Z</published>
    <updated>2017-02-27T14:33:51.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>为了验证这个游戏到底有没有 SSR</p>
<a id="more"></a>
<h2 id="0x01-前期工作"><a href="#0x01-前期工作" class="headerlink" title="0x01 前期工作"></a>0x01 前期工作</h2><p>直接将 <code>onmyoji_netease_1.0.14.apk</code> 解压出来观察各个文件，便可以知道阴阳师是使用 <code>NeoX + Python</code>。
其中 <code>lib/armeabi-v7a/libclient.so</code> 和 <code>assets/script.npk</code> 这两个文件，
一个是带着 Python 虚拟机以及加解密相关的 so 文件，一个是加密之后的 Python 文件，
所以我们后期的工作中心也主要放在这两个文件上。</p>
<p>为了能够在后面调试阴阳师，我们需要对阴阳师重打包：</p>
<ol>
<li><p>使用 <code>apktool</code> 解包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">apktool d onmyoji_netease_1.0.14.apk</div></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>debuggable</code><br>将 <code>AndroidManifest.xml</code> 中的 <code>debuggable</code> 修改为 <code>true</code></p>
</li>
<li><p>重打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">apktool b onmyoji_netease_1.0.14</div></pre></td></tr></table></figure>
</li>
<li><p>签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java -jar signapk.jar platform.x509.pem platform.pk8 onmyoji_netease_1.0.14.apk onmyoji_netease_1.0.14_fix.apk</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="0x02-Android-调试初试"><a href="#0x02-Android-调试初试" class="headerlink" title="0x02 Android 调试初试"></a>0x02 Android 调试初试</h2><p>由于我是第一次进行 Android 调试，所以这里我写得稍微啰嗦一点儿。</p>
<ol>
<li><p>关闭SELinux</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">setenforce 0</div></pre></td></tr></table></figure>
</li>
<li><p>运行 android_server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/data/android_server</div></pre></td></tr></table></figure>
</li>
<li><p>将 android_server 的端口转发到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">adb forward tcp:23946 tcp:23946</div></pre></td></tr></table></figure>
</li>
<li><p>启动阴阳师</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">am start -D -n  com.netease.onmyoji/com.netease.onmyoji.Launcher</div></pre></td></tr></table></figure>
</li>
<li><p>IDA 远程 Attach</p>
<img src="http://static.fatezero.org/blog/img/decrypt-onmyoji/ida_remote_attach.png">
</li>
<li><p>IDA 设置调试选项</p>
<img src="http://static.fatezero.org/blog/img/decrypt-onmyoji/ida_debug_option.png">
</li>
<li><p>将阴阳师的调试端口转发到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ps | grep netease.onmyoji</div><div class="line">adb forward tcp:17178 jdwp:process_pid</div></pre></td></tr></table></figure>
</li>
<li><p>jdb 附加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=17178</div></pre></td></tr></table></figure>
</li>
</ol>
<p>由于种种原因，我需要重开很多次阴阳师，所以我就将步骤 7，8 合并成一个 <code>copy &amp; paste</code> 的命令
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for /f &quot;delims=&quot; %i in (&apos;adb shell &quot;set `ps |grep netease.onmyoji`; echo -n $2&quot;&apos;) do adb forward tcp:17178 jdwp:%i &amp;&amp; jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=17178</div></pre></td></tr></table></figure></p>
<h2 id="0x03-open-amp-read"><a href="#0x03-open-amp-read" class="headerlink" title="0x03 open &amp; read"></a>0x03 open &amp; read</h2><p>之前我也说过了，<code>lib/armeabi-v7a/libclient.so</code> 和 <code>assets/script.npk</code> 这两个是重点文件，在 <code>libclient.so</code> 加载之后，自然要关注一下 <code>script.npk</code>。</p>
<p>要想解密 <code>script.npk</code>，基本思路还是挺简单的：关注 <code>script.npk</code> 读取的数据经过了怎么样的处理。</p>
<p>为了更好的将 <code>read</code> 函数中的 fd 与文件名对应，我在 <code>open</code> 处下条件断点，并加上下面的判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> idc</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(idc, <span class="string">"fd_map"</span>):</div><div class="line">    idc.fd_map = &#123;&#125;</div><div class="line"></div><div class="line">filename = GetString(cpu.r0)</div><div class="line"></div><div class="line"><span class="keyword">if</span> filename <span class="keyword">and</span> <span class="string">"script.npk"</span> <span class="keyword">in</span> filename:</div><div class="line">    StepUntilRet()</div><div class="line">    GetDebuggerEvent(WFNE_SUSP, <span class="number">-1</span>)</div><div class="line">    fd = cpu.r0</div><div class="line">    continue_process()</div><div class="line">    <span class="keyword">if</span> fd != idaapi.BADADDR:</div><div class="line">        print(<span class="string">"open: %s fd: %s"</span> % (filename, fd))</div><div class="line">        idc.fd_map[fd] = filename</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">"open: %s"</span> % filename)</div><div class="line">    </div><div class="line"><span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>上面的代码主要是将和 <code>script.npk</code> 相关的 fd 和文件名关联起来，方便于在 <code>read</code> 调用时区分和 <code>script.npk</code> 相关的读取操作。</p>
<p><code>read</code> 函数条件断点代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> idc</div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(idc, <span class="string">'fd_map'</span>):</div><div class="line">    <span class="keyword">return</span></div><div class="line"></div><div class="line">fd = cpu.r0</div><div class="line"></div><div class="line"><span class="keyword">if</span> fd <span class="keyword">in</span> idc.fd_map:</div><div class="line">    print(<span class="string">"reading: %s"</span> % idc.fd_map[fd])</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    </div><div class="line"><span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="0x"><a href="#0x" class="headerlink" title="0x??"></a>0x??</h2><p>TODO</p>
<h2 id="0x-迷一般的-opcode"><a href="#0x-迷一般的-opcode" class="headerlink" title="0x?? 迷一般的 opcode"></a>0x?? 迷一般的 opcode</h2><p>为了计算出正确的 <code>opcode</code>，我写了一份使用了所有 <code>Python 2.7 opcode</code> 的文件： <a href="https://gist.github.com/fate0/3e1d23bce9d4d2cfa93848dd92aba3d4" target="_blank" rel="external">pyopcode.py</a></p>
<p>TODO</p>
<p>除了上面的方法外，我们还可以使用 <a href="https://www.hex-rays.com/products/ida/support/tutorials/debugging_appcall.pdf" target="_blank" rel="external">IDA Appcall</a>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">test = Appcall.proto(<span class="string">'PyRun_SimpleString'</span>, <span class="string">'int PyRun_SimpleString(char *);'</span>)</div><div class="line"><span class="comment"># test.options = Appcall.APPCALL_MANUAL</span></div><div class="line"><span class="keyword">print</span> test(<span class="string">"open('/sdcard/test123.txt', 'w+').write(str(sys.path))"</span>)</div></pre></td></tr></table></figure></p>
<p><code>Appcall</code> 比上面的方法更好的是它处于程序的运行状态，程序运行中的数据，使用 <code>Appcall</code> 都可以接触到。</p>
<p>但是这招实在没法不吐槽：优点非常好用，缺点时灵时不灵。</p>
<h2 id="0x-花样使用-IDAPython"><a href="#0x-花样使用-IDAPython" class="headerlink" title="0x?? 花样使用 IDAPython"></a>0x?? 花样使用 IDAPython</h2><h4 id="1-尝试自动化"><a href="#1-尝试自动化" class="headerlink" title="1. 尝试自动化"></a>1. 尝试自动化</h4><p>因为要经常重开阴阳师，但是每次重新调试都需要我手动重复暂停继续等待加载 <code>libclient.so</code>，所以我写了这么一个 IDAPython Script:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> idc <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> idautils <span class="keyword">import</span> *</div><div class="line"></div><div class="line">bt_cond = <span class="string">"""</span></div><div class="line">filename = GetString(cpu.r0)</div><div class="line">print("loading: %s" % filename)</div><div class="line"></div><div class="line">if not filename:</div><div class="line">    return True</div><div class="line"></div><div class="line">if filename == "libclient.so":</div><div class="line">    return True</div><div class="line">"""</div><div class="line">add_bpt(LocByName(<span class="string">'__dl__ZL17soinfo_link_imageP6soinfoPK17android_dlextinfo'</span>), <span class="number">0</span>, BPT_SOFT)</div><div class="line">enable_bpt(LocByName(<span class="string">'__dl__ZL17soinfo_link_imageP6soinfoPK17android_dlextinfo'</span>), <span class="keyword">True</span>)</div><div class="line">SetBptCnd(LocByName(<span class="string">'__dl__ZL17soinfo_link_imageP6soinfoPK17android_dlextinfo'</span>), bt_cond)</div></pre></td></tr></table></figure>
<p>看着是没什么问题，但是有时候 <code>GetString(cpu.r0)</code> 返回一个 <code>idaapi.BADADDR</code>，所以 IDA 暂停了，
但是暂停的时候去查看这个地址的内容却发现是正常数据，并不是 <code>idaapi.BADADDR</code>。这个谜一般的情况我并没有去解决，后面我还是老老实实手动。</p>
<h4 id="2-尝试分析函数"><a href="#2-尝试分析函数" class="headerlink" title="2. 尝试分析函数"></a>2. 尝试分析函数</h4><p>当一些断点断下来的时候，在动态调试的窗口只能看到运行指令以及之后的几条指令，虽然说也可以一直按 <code>C</code> 键，
但是总这样也挺不方便的，所以我将静态调试的 IDA 中<code>text</code> 段的函数地址全部导出到 <code>d:\\ida.txt</code> 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">funclist = []</div><div class="line"><span class="keyword">for</span> seg_ea <span class="keyword">in</span> Segments():</div><div class="line">    <span class="keyword">if</span> SegName(seg_ea) != <span class="string">'.text'</span>:</div><div class="line">        <span class="keyword">continue</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> function_ea <span class="keyword">in</span> Functions(SegStart(seg_ea), SegEnd(seg_ea)):</div><div class="line">        funclist.append(function_ea)</div><div class="line"></div><div class="line">py_init = LocByName(<span class="string">'Py_Initialize'</span>)</div><div class="line">funclist.insert(<span class="number">0</span>, py_init)</div><div class="line"></div><div class="line">open(<span class="string">'d:\\ida.txt'</span>, <span class="string">'w'</span>).write(json.dumps(funclist))</div><div class="line">print(<span class="string">'done'</span>)</div></pre></td></tr></table></figure>
<p>然后再将 <code>d:\\ida.txt</code> 的内容再导入到动态调试的 IDA 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line">funclist = json.loads(open(<span class="string">'d:\\ida.txt'</span>).read())</div><div class="line"></div><div class="line">daynamic_py_init = LocByName(<span class="string">'Py_Initialize'</span>)</div><div class="line">static_py_init = funclist.pop(<span class="number">0</span>)</div><div class="line"></div><div class="line">offset = daynamic_py_init - static_py_init</div><div class="line"></div><div class="line"><span class="keyword">for</span> function_ea <span class="keyword">in</span> funclist:</div><div class="line">    MakeFunction(function_ea + offset)</div><div class="line"></div><div class="line">print(<span class="string">'done'</span>)</div></pre></td></tr></table></figure>
<p>然而因为 <code>libclient.so</code> 中的 <code>text</code> 段有 1w 多个函数，导入的时候 <code>MakeFunction</code> 实在太慢了，
大概要等五分钟才好，用了几次之后我就放弃了这样的方法。</p>
<h4 id="3-显示调用堆栈"><a href="#3-显示调用堆栈" class="headerlink" title="3. 显示调用堆栈"></a>3. 显示调用堆栈</h4><p>不知道为什么我的 <code>Call Stack</code> 一直显示任何东西，不确定是手机的问题还是 IDA 的问题，还是这个 App 的问题，折腾这问题感觉很麻烦。
因为 fp 寄存器还保存着程序的返回地址，所以还是直接写个 IDAPython Script 打印出调用堆栈比较方便的(如果 fp 不能用，可以参考 <a href="http://www.hexblog.com/?p=104" target="_blank" rel="external">An attempt to reconstruct the call stack</a>)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> idaapi, idautils</div><div class="line"></div><div class="line">static_py_init = <span class="number">0x1285398</span></div><div class="line">dynamic_py_init = LocByName(<span class="string">'Py_Initialize'</span>)</div><div class="line">offset = dynamic_py_init - static_py_init</div><div class="line"></div><div class="line">f_fp = idautils.cpu.fp</div><div class="line">f_pc = <span class="number">0</span></div><div class="line"></div><div class="line">i = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> i &lt; <span class="number">100</span>:</div><div class="line">    i += <span class="number">1</span></div><div class="line">    f_pc = Dword(f_fp)</div><div class="line">    f_fp = Dword(f_fp<span class="number">-4</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> f_fp == idaapi.BADADDR:</div><div class="line">        <span class="keyword">break</span></div><div class="line"></div><div class="line">    print(<span class="string">"%s %s"</span> % (hex(f_pc), hex(f_pc - offset)))</div><div class="line"></div><div class="line">print(<span class="string">'==============================='</span>)</div></pre></td></tr></table></figure>
<h2 id="0x-简单写个挂"><a href="#0x-简单写个挂" class="headerlink" title="0x?? 简单写个挂"></a>0x?? 简单写个挂</h2><p>看了代码之后，发现抽卡的爆率不在本地，但是百鬼夜行的碎片掉率是在本地计算的，简单看一下相关代码片段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># scenemembers/GhostWalkScene.py</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GhostWalkScene</span><span class="params">(GameScene)</span>:</span></div><div class="line">    <span class="comment"># 省略 ...</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CheckFairGhostIsHit</span><span class="params">(self, ghostID, model)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span>  <span class="comment"># modify by fate0</span></div><div class="line">        modelIndex = self.FairModelIndexDict[model]</div><div class="line">        </div><div class="line">        <span class="comment"># 省略 ...</span></div><div class="line"></div><div class="line">        data = random.randint(<span class="number">1</span>, <span class="number">100</span>)</div><div class="line">        <span class="keyword">if</span> data &lt;= int(hitRate * <span class="number">100</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CheckEffectGhostIsHit</span><span class="params">(self, id)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span>  <span class="comment"># modify by fate0</span></div><div class="line">        rate = float(GhostWalkFairData.data[int(id)][<span class="string">'rate'</span>])</div><div class="line">        </div><div class="line">        <span class="comment"># 省略 ...</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> randInt &lt;= int(rate * <span class="number">100.0</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FireBean</span><span class="params">(self, offsetX, offsetY)</span>:</span></div><div class="line">        helpers.createModelAsync(<span class="string">'model/douzi/douzi.gim'</span>, self.FireBeanCallback, (<span class="number">0.3</span>,</div><div class="line">         offsetX,</div><div class="line">         offsetY,</div><div class="line">         self.PlayerModel))</div><div class="line">        self.TotalBeanNum = self.TotalBeanNum + <span class="number">1</span>  <span class="comment"># modify by fate0</span></div><div class="line">        </div><div class="line">        <span class="comment"># 省略 ...</span></div></pre></td></tr></table></figure>
<ul>
<li><code>CheckFairGhostIsHit</code>: 用来检查走过的式神是否被击中</li>
<li><code>CheckEffectGhostIsHit</code>: 用来检查飞过的状态是否被击中</li>
<li><code>FireBean</code>: 开火</li>
</ul>
<p>所以让 <code>CheckFairGhostIsHit</code> 和 <code>CheckEffectGhostIsHit</code> 这两个方法返回 <code>True</code> 就可以实现百分百命中，
将 <code>self.TotalBeanNum = self.TotalBeanNum - 1</code> 修改成 <code>self.TotalBeanNum = self.TotalBeanNum + 1</code> 就可以实现无限福豆。</p>
<p>视频演示：</p>
<video src="http://static.fatezero.org/blog/video/decrypt-onmyoji/demo.mp4" type="video/mp4" controls="controls" width="100%" height="100%">
</video>

<h2 id="0x-总结"><a href="#0x-总结" class="headerlink" title="0x?? 总结"></a>0x?? 总结</h2><p>第一次逆 Android 程序，感悟就是手机竟然还会有广告？</p>
<h2 id="0x-更新"><a href="#0x-更新" class="headerlink" title="0x?? 更新"></a>0x?? 更新</h2><p>找到一个对任意用户或者对任意频道用户拒绝服务的漏洞，奖励:</p>
<img src="http://static.fatezero.org/blog/img/decrypt-onmyoji/reward.png">
<iframe src="//music.163.com/outchain/player?type=2&id=588640&auto=0&height=66" width="500" height="86" frameborder="0" allowfullscreen></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;为了验证这个游戏到底有没有 SSR&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Komm, süsser Tod</title>
    <link href="http://blog.fatezero.org/2016/12/21/Komm-susser-Tod/"/>
    <id>http://blog.fatezero.org/2016/12/21/Komm-susser-Tod/</id>
    <published>2016-12-21T22:53:27.000Z</published>
    <updated>2017-02-27T14:33:51.052Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的意义在于测试这个主题所支持的功能</p>
<a id="more"></a>
<h2 id="测试-MarkDown-功能"><a href="#测试-MarkDown-功能" class="headerlink" title="测试 MarkDown 功能"></a>测试 MarkDown 功能</h2><h4 id="0x1-表格"><a href="#0x1-表格" class="headerlink" title="0x1. 表格"></a>0x1. 表格</h4><table>
<thead>
<tr>
<th style="text-align:left">靠左表头</th>
<th style="text-align:center">居中表头</th>
<th style="text-align:right">靠右表头</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>content</code></td>
<td style="text-align:center">内容</td>
<td style="text-align:right">$a=1$</td>
</tr>
<tr>
<td style="text-align:left"><em>内容</em></td>
<td style="text-align:center">$a^3$</td>
<td style="text-align:right"><strong>内容</strong></td>
</tr>
</tbody>
</table>
<h4 id="0x2-代码"><a href="#0x2-代码" class="headerlink" title="0x2. 代码"></a>0x2. 代码</h4><p>这里是代码块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">print(<span class="string">"hello world"</span>)</div></pre></td></tr></table></figure>
<p>这里是行内代码 <code>print(&quot;hello world&quot;)</code></p>
<h4 id="0x3-引用"><a href="#0x3-引用" class="headerlink" title="0x3. 引用"></a>0x3. 引用</h4><blockquote>
<p>这里是引用
第二行引用</p>
</blockquote>
<h4 id="0x4-链接"><a href="#0x4-链接" class="headerlink" title="0x4. 链接"></a>0x4. 链接</h4><p><a href="http://blog.fatezero.org">我的博客</a>
<a href="http://wiki.fatezero.org" target="_blank" rel="external">我的wiki</a></p>
<h4 id="0x5-图片"><a href="#0x5-图片" class="headerlink" title="0x5. 图片"></a>0x5. 图片</h4><p><img src="https://octodex.github.com/images/privateinvestocat.jpg" alt="privateinvestocat"></p>
<h2 id="测试-mathjax"><a href="#测试-mathjax" class="headerlink" title="测试 mathjax"></a>测试 mathjax</h2><p>这里是数学公式块</p>

$$
        \begin{matrix}
        1 & x & x^2 \\
        1 & y & y^2 \\
        1 & z & z^2 \\
        \end{matrix}
$$

<p>这个是行内数学公式 $\sqrt[4]{\frac xy}$</p>
<h2 id="测试-Hexo-功能"><a href="#测试-Hexo-功能" class="headerlink" title="测试 Hexo 功能"></a>测试 Hexo 功能</h2><h4 id="0x1-img"><a href="#0x1-img" class="headerlink" title="0x1. img"></a>0x1. img</h4><img src="https://octodex.github.com/images/privateinvestocat.jpg" width="200" height="200">
<p>一般使用 Hexo 内的图片 tag, 因为可以调整图片大小</p>
<h4 id="0x2-raw"><a href="#0x2-raw" class="headerlink" title="0x2. raw"></a>0x2. raw</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;% raw %&#125;</div><div class="line">content</div><div class="line">&#123;% endraw %&#125;</div></pre></td></tr></table></figure>
<h4 id="0x3-主题-tip"><a href="#0x3-主题-tip" class="headerlink" title="0x3. 主题 tip"></a>0x3. 主题 tip</h4><div class="tip">
    这个是主题带的 tip
</div>

<h4 id="0x4-iframe"><a href="#0x4-iframe" class="headerlink" title="0x4. iframe"></a>0x4. iframe</h4><iframe src="//music.163.com/outchain/player?type=2&id=31365696&auto=0&height=66" width="500" height="86" frameborder="0" allowfullscreen></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章的意义在于测试这个主题所支持的功能&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
