<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 爬虫 JavaScript 篇[Web 漏洞扫描器] · fate0</title><meta name="description" content="爬虫 JavaScript 篇[Web 漏洞扫描器] - fate0"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.fatezero.org/atom.xml" title="fate0"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?345ca1db7809172aec8db3a78e7679c4";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://www.fatezero.org" target="_blank" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">爬虫 JavaScript 篇[Web 漏洞扫描器]</h1><div class="post-info">Apr 9, 2018</div><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p><a href="http://blog.fatezero.org/2018/03/05/web-scanner-crawler-01/">上一篇</a>主要讲了如何通过修改 Chromium 代码为 Web 漏洞扫描器的爬虫打造一个稳定可靠的 headless 浏览器。这一篇我们从浏览器底层走到上层，从 C++ 切换到 JavaScript，讲一下如何通过向浏览器页面注入 JavaScript 代码来尽可能地获取页面上的链接信息。</p>
<a id="more"></a>
<h2 id="0x01-注入-JavaScript-的时间点"><a href="#0x01-注入-JavaScript-的时间点" class="headerlink" title="0x01 注入 JavaScript 的时间点"></a>0x01 注入 JavaScript 的时间点</h2><p>首先我们要解决的第一个问题是：在什么时间点向浏览器页面注入 JavaScript 代码？</p>
<p>答案非常简单，
在页面加载前，我们希望能够注入一段 JavaScript 代码以便于能够 Hook、备份各种未被污染的函数，
在页面加载后，我们希望能够注入一段 JavaScript 代码以便于能够进行遍历各个元素、触发各种事件、获取链接信息等操作。</p>
<p>那么下一个问题又来了：怎么定义页面加载前、页面加载后？</p>
<p>页面加载前的定义非常简单，只要能在用户代码执行前执行我们注入的 JavaScript 代码即可，也就是在页面创建之后、用户代码执行之前的时间段对于我们来说都算是页面加载前，CDP 刚好提供了这么一个 API 
<a href="https://chromedevtools.github.io/devtools-protocol/tot/Page#method-addScriptToEvaluateOnNewDocument" target="_blank" rel="noopener"><code>Page.addScriptToEvaluateOnNewDocument</code></a> 能够让我们在页面加载前注入 JavaScript 代码。</p>
<p>接下来考虑一下该如何定义页面加载后。最简单的方法就是不管三七二一，每个页面都加载 30s (即便是空白的页面)，随后再注入我们的代码，但很明显这会浪费很多资源，我们需要根据每个页面的复杂度来控制加载时间。可能会有同学说我们可以监听 <code>load</code> 事件，等待页面加载结束之后再注入代码，那我们考虑一个比较常见的场景，在某个页面上刚好有那么一两个图片字体资源加载速度特别慢，导致 <code>load</code> 迟迟未被触发(甚至不触发)，但这些资源其实我们并不在乎，完全可以直接注入我们代码，所以只等待 <code>load</code> 事件也并不是一个特别好的选择。</p>
<p>我们先看一下加载一个页面的过程，除了会触发 <code>load</code> 事件之外还会触发什么事件:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在外部 script 之前的 css 会阻塞 DOM 的构建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://httpbin.org/delay/3?id=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://httpbin.org/delay/1?id=2"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 后面两个 css 并不会阻塞 DOM 的构建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://httpbin.org/delay/6?id=3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://httpbin.org/delay/6?id=4"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"><span class="keyword">import</span> pychrome.exceptions</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lifecycleEvent</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;&#125;: &#123;&#125;"</span>.format(kwargs[<span class="string">'timestamp'</span>], kwargs[<span class="string">'name'</span>]))</span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line">tab = browser.new_tab()</span><br><span class="line"></span><br><span class="line">tab.Page.lifecycleEvent = lifecycleEvent</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line">tab.Page.enable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    tab.Page.setLifecycleEventsEnabled(enabled=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">except</span> pychrome.exceptions.CallMethodException:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">tab.Page.navigate(url=<span class="string">"http://localhost/load_event.html"</span>)</span><br><span class="line">tab.wait(<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/carbon.png" width="350">
<p>下面我们简单地介绍一下上面几个我们会用到的事件</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>DOMContentLoaded</td>
<td>一般表示 DOM 和 CSSOM 均准备就绪的时间点</td>
</tr>
<tr>
<td>networkAlmostIdle</td>
<td>当前网络连接数少于 2 后触发</td>
</tr>
<tr>
<td>networkIdle</td>
<td>当前没有网络连接后触发</td>
</tr>
<tr>
<td>load</td>
<td>网页所有资源载入后触发，浏览器上加载转环停止旋转</td>
</tr>
</tbody>
</table>
<p>之前解释过 <code>load</code> 事件可能对我们来说太晚了，但是现在 <code>DOMContentLoaded</code> 事件对我们来说又太早了，因为用户代码也可能会绑定这个事件然后操作 DOM，我们肯定是希望能够在页面稳定之后再注入我们的代码，所以在 <code>load</code> 和 <code>DOMContentLoaded</code> 之间某个时间点对我们来说比较合适，可惜并没有这样一个特别的事件存在，所以我个人觉得比较好的方案是将上面各个事件结合一起使用。</p>
<p>我们先说一下这几个事件的触发顺序，首先这几个事件触发顺序不一定，例如触发时间 <code>load</code> 事件不一定比 <code>DOMContentLoaded</code> 晚，<code>load</code> 也不一定比 <code>networkAlmostIdle</code> 晚。唯一能确定的就是 <code>networkAlmostIdle</code> 一定比 <code>networkIdle</code> 晚。在一般的情况下时间顺序是 <code>DOMContentLoaded</code> -&gt; <code>networkAlmostIdle</code> -&gt; <code>networkIdle</code> -&gt; <code>load</code>。</p>
<p>所以一般的解决方案：</p>
<ol>
<li>等待 <code>load</code>，同时设定等待超时时间，<code>load</code> 超时直接注入代码，同时等待 <code>DOMContentLoaded</code> 事件</li>
<li><code>DOMContentLoaded</code> 事件触发，接着等待 <code>networkAlmostIdle</code>，同时设定等待超时时间，超时直接注入代码</li>
<li><code>networkAlmostIdle</code> 事件触发，接着等待 <code>networkIdle</code> 同时设定等待超时时间，超时直接注入代码</li>
</ol>
<p>如果 <code>load</code> 事件在其他事件前触发，那就直接注入代码。</p>
<h2 id="0x02-DOM-构建前"><a href="#0x02-DOM-构建前" class="headerlink" title="0x02 DOM 构建前"></a>0x02 DOM 构建前</h2><p>解决了在什么时候注入 JavaScript 代码的问题，接下来我们该开始考虑第一阶段该注入什么代码了。</p>
<p>由于在第一阶段的时间点，DOM 树还未构建，所以我们所注入的代码均不能操作 DOM，能干的事情也就只有 Hook、备份 BOM 中的函数。</p>
<h4 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h4><p>我们先把一些会导致页面阻塞、关闭的函数给 Hook 了，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="built_in">window</span>.prompt = <span class="function"><span class="keyword">function</span> (<span class="params">msg, input</span>) </span>&#123; <span class="keyword">return</span> input; &#125;;</span><br><span class="line"><span class="built_in">window</span>.confirm = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;;</span><br><span class="line"><span class="built_in">window</span>.close = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>同时也需要在 CDP 中处理 <code>Page.javascriptDialogOpening</code> 事件，因为还有类似 <code>onbeforeunload</code> 这样的弹窗。</p>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>还记得我们上一篇通过修改 Chromium 代码将 <code>location</code> 变成可伪造的事情了吗？就是为了能够在这里对 <code>location</code> 直接 Hook，直接看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oldLocation = <span class="built_in">window</span>.location;</span><br><span class="line"><span class="keyword">var</span> fakeLocation = <span class="built_in">Object</span>();</span><br><span class="line">fakeLocation.replace = fakeLocation.assign = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + value);</span><br><span class="line">&#125;;</span><br><span class="line">fakeLocation.reload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">fakeLocation.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> oldLocation.toString();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(fakeLocation, &#123;</span><br><span class="line">    <span class="string">'href'</span>: &#123;</span><br><span class="line">        <span class="string">'get'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oldLocation.href; &#125;,</span><br><span class="line">        <span class="string">'set'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + value); &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// hash, host, hostname ...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> replaceLocation = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">'location'</span>, &#123;</span><br><span class="line">        <span class="string">'get'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> fakeLocation; &#125;,</span><br><span class="line">        <span class="string">'set'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + value); &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">replaceLocation(<span class="built_in">window</span>);</span><br><span class="line">addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    replaceLocation(<span class="built_in">document</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里还需要注意的是 <code>doucment.location</code> 需要等待 DOM 构建结束之后才能 hook, 所以需要注册 <code>DOMContentLoaded</code> 事件来 hook <code>document.location</code>。</p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>因为之前我们修改了 <code>Chromium</code> 代码使得 <code>window.open</code> 无法新建窗口，这样在 CDP 中也没法获取 <code>window.open</code> 想打开的链接信息，所以我们还需要在代码中 Hook <code>window.open</code> 函数：
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + url); &#125;;</span><br></pre></td></tr></table></figure></p>
<p>还有我们比较常用的 AJAX：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.XMLHttpRequest.prototype.send = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录发送的数据，注意 data 可能是 raw data </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.XMLHttpRequest.prototype.open = <span class="function"><span class="keyword">function</span> (<span class="params">method, url, async, user, password</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录 method, url 等信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.XMLHttpRequest.prototype.setRequestHeader = <span class="function"><span class="keyword">function</span> (<span class="params">header, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录 header</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.XMLHttpRequest.prototype.abort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>hook XHR 时要考虑的问题就是在 XHR 正在发送请求的时候，需不需要暂停我们的其他操作（如触发事件）？ 
我们注入的代码的下一个操作可能会中断正在发送的 XHR 请求，导致更多链接的丢失，
比较典型的例子就是：<a href="http://testphp.vulnweb.com/AJAX/index.php" target="_blank" rel="noopener">AJAX Demo</a>，这个问题没有标准答案。</p>
<p><code>WebSocket</code>、<code>EventSource</code>、<code>fetch</code> 和 XHR 差不多：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oldWebSocket = <span class="built_in">window</span>.WebSocket;</span><br><span class="line"><span class="built_in">window</span>.WebSocket = <span class="function"><span class="keyword">function</span>(<span class="params">url, arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> oldWebSocket(url, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldEventSource = <span class="built_in">window</span>.EventSource;</span><br><span class="line"><span class="built_in">window</span>.EventSource = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> oldEventSource(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldFetch = <span class="built_in">window</span>.fetch;</span><br><span class="line"><span class="built_in">window</span>.fetch = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + url);</span><br><span class="line">    <span class="keyword">return</span> oldFetch(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>我们还需要 hook 两个定时器函数：</p>
<ul>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
</ul>
<p>因为可能用户代码会延迟或者定期做一些操作，我们可能等不来那么长的时间，所以我们要给这些定时器做一个加速，
也就是 Hook 之后修改相对应的 delay 为更小的值，同时加速之后也要 hook <code>Date</code> 类来同步时间。</p>
<h4 id="锁定"><a href="#锁定" class="headerlink" title="锁定"></a>锁定</h4><p>我们可以 hook 这些函数，那么其他人也可以继续 hook 这些函数，但一般对这些函数进行 hook 的人都不是什么好人，
被别人继续 hook 之后可能会影响到我们的代码，所以我们还需要锁定这些基础函数。</p>
<p>例子：
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'hook before defineProperty'</span>); &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'open'</span>, &#123;</span><br><span class="line">    value: <span class="built_in">window</span>.open,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.open = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'hook after defineProperty'</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.open(<span class="string">'http://www.fatezero.org'</span>)</span><br></pre></td></tr></table></figure></p>
<p>结果：
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hook before defineProperty</span><br></pre></td></tr></table></figure></p>
<p>第一阶段我们能做的事情也做得差不多了，剩下的事情就交给第二阶段的代码干了。</p>
<h2 id="0x03-遍历节点"><a href="#0x03-遍历节点" class="headerlink" title="0x03 遍历节点"></a>0x03 遍历节点</h2><p>第二阶段，也就是页面稳定后，我们肯定是要先遍历 DOM 中的各个节点，
然后才能获取节点上的链接信息，以及触发节点上绑定的事件，所以这里我们看一下获取 DOM 中所有的节点，有哪些方法：</p>
<ul>
<li>CDP 的 <code>DOM.querySelectorAll</code></li>
<li>document.all</li>
<li>document.querySelectorAll</li>
<li>TreeWalker</li>
</ul>
<p>我们一个一个的排除，
首先排除 CDP，因为如果使用 CDP 遍历各个节点，那就意味着后续的对节点的操作也要继续使用 CDP 才能进行，其速度远没有在一个 Context 内的代码操作 DOM 快。
接着排除 <code>document.all</code>(<code>HTMLAllCollection</code>，动态元素集合) 和 <code>document.querySelectorAll</code>(<code>NodeList</code>, 静态元素集合)，因为这两个都只是元素集合，而不是节点集合，
并不包含 text, comment 节点。最后就剩下 TreeWalker 了。</p>
<p>TreeWalker 也有两种玩法，一种是先获取所有的节点，然后在触发各个节点上的事件，另外一种是边遍历节点，边触发事件。</p>
<p>可能会有同学觉得第二种方法比较优雅，我们看一下使用第二种方法的一种情况：
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"a1"</span>&gt;</span>hello a1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"a2"</span> <span class="attr">onclick</span>=<span class="string">"removeA2()"</span>&gt;</span>hello a2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"a3"</span>&gt;</span>hello a3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">removeA2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span></span><br><span class="line"><span class="javascript">    c.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'a2'</span>));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">treeWalkerFilter</span>(<span class="params">element</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (element.nodeType === Node.ELEMENT_NODE) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> NodeFilter.FILTER_ACCEPT;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">treeWalker = <span class="built_in">document</span>.createTreeWalker(</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>,</span></span><br><span class="line">    NodeFilter.SHOW_ELEMENT,</span><br><span class="line">    treeWalkerFilter,</span><br><span class="line"><span class="javascript">    <span class="literal">false</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">while</span> (treeWalker.nextNode()) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"[*] processing node "</span> + treeWalker.currentNode.tagName + <span class="string">' '</span> + treeWalker.currentNode.id);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (treeWalker.currentNode.click) &#123;</span></span><br><span class="line">        treeWalker.currentNode.click();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(treeWalker.currentNode);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果：</p>
<img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/treewalker.png" width="400">
<p>是的，如果 TreeWalker 刚好走到一个节点，触发了事件使得该节点离开了 DOM 树，那 TreeWalker 就走不下去了，
所以比较保险的方法就是在页面稳定后收集一份静态的节点列表，再触发事件，也就是使用 <code>TreeWalker</code> 的第一种玩法。</p>
<h2 id="0x04-事件触发"><a href="#0x04-事件触发" class="headerlink" title="0x04 事件触发"></a>0x04 事件触发</h2><p>在收集到一份静态节点列表，获取静态节点列表的链接信息之后，我们就该考虑一下如何触发各个节点上的事件了。</p>
<p>首先，我们来谈一下如何触发鼠标、键盘相关的事件，主要方法有两：</p>
<ul>
<li><code>dispatchEvent</code></li>
<li>CDP 的 <code>Input.dispatchMouseEvent</code></li>
</ul>
<p>我们使用一个简单的例子看一下两者最大的差别：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">onclick</span>=<span class="string">"testEventTrusted(event)"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">testEventTrusted</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="string">"isTrusted"</span> <span class="keyword">in</span> event) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (event.isTrusted) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"trusted"</span>);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"not trusted"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"not support"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 CDP 测试两者区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line"></span><br><span class="line">tab = browser.new_tab()</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line">tab.Page.navigate(url=<span class="string">"http://localhost/test.html"</span>)</span><br><span class="line"></span><br><span class="line">tab.Runtime.enable()</span><br><span class="line">tab.Runtime.evaluate(expression=<span class="string">"console.log('js click: ')"</span>)</span><br><span class="line">tab.Runtime.evaluate(expression=<span class="string">"var e = new MouseEvent('click');test.dispatchEvent(e);"</span>, _timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">result = tab.Runtime.evaluate(expression=<span class="string">'test'</span>, _timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">btn_object_id = result[<span class="string">'result'</span>][<span class="string">'objectId'</span>]</span><br><span class="line">result = tab.DOM.getBoxModel(objectId=btn_object_id)</span><br><span class="line"></span><br><span class="line">border = result[<span class="string">'model'</span>][<span class="string">'border'</span>]</span><br><span class="line"></span><br><span class="line">odd = [value <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(border) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>]</span><br><span class="line">even = [value <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(border) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">x = min(even)</span><br><span class="line">y = min(odd)</span><br><span class="line">width = max(even) - x</span><br><span class="line">height = max(odd) - y</span><br><span class="line"></span><br><span class="line">x += width / <span class="number">2</span></span><br><span class="line">y += height / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">tab.Runtime.evaluate(expression=<span class="string">"console.log('cdp click: ')"</span>)</span><br><span class="line">tab.Input.dispatchMouseEvent(type=<span class="string">"mousePressed"</span>, x=x, y=y, button=<span class="string">'left'</span>, clickCount=<span class="number">1</span>)</span><br><span class="line">tab.Input.dispatchMouseEvent(type=<span class="string">"mouseReleased"</span>, x=x, y=y, button=<span class="string">'left'</span>, clickCount=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/event_js_and_cdp_result.png" width="280">
<p><code>dispatchEvent</code> 和 <code>Input.dispatchMouseEvent</code> 这两者最大的区别就是事件来源是否是真实的用户点击，
虽说 <code>isTrusted</code> 也就是一个改 Chromium 代码就能解决的问题，但我们也没法保证还有没有其他黑科技来检测是否事件是否来自真实用户。
然而我还是觉得 CDP 实在太慢，所以还是继续选择使用 <code>dispatchEvent</code> 来触发各种事件。</p>
<p>接下来我们要考虑一下如何使用 <code>dispatchEvent</code> 触发事件，
可能有些同学觉得，我们可以扫描所有元素节点，收集内联事件，对于动态添加的事件，可以 Hook <code>addEventListener</code> 获取到，
最后再挨个触发元素相对应的事件，其实这样做是有问题的。</p>
<p>我们还是先看看一个例子：
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">onclick</span>=<span class="string">"btnClick(event)"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span>&gt;</span>click1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn2"</span>&gt;</span>click2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">btnClick</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'click: '</span> + e.target.id);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>例子将事件绑定在 container 内，等事件冒泡到 container，再通过 event.target 区分元素。
如果按照之前的思路，我们的代码将会在 container 中触发一个点击事件，而忽略了 container 下的两个按钮，所以之前的思路并不合理。</p>
<p>我个人的想法是，每个元素都只触发常用的事件，比如说 <code>click</code>、<code>dbclick</code>、<code>mouseover</code> 等事件，忽略一些非主流事件。
只触发常见的键盘、鼠标事件让我们的行为更像是一个正常人类的行为，这样也减少了被反爬虫机制带入坑的可能性。
另外，说到爬虫行为做到和正常人类类似，还有一个小细节，那就是元素是否在可见区域，
以前都是直接将浏览器的 viewpoint 设置最大，现在我们使用 <code>element.scrollIntoViewIfNeeded</code> 将滚动条滚动到元素的位置，然后再触发事件。</p>
<h2 id="0x05-新节点"><a href="#0x05-新节点" class="headerlink" title="0x05 新节点"></a>0x05 新节点</h2><p>那么问题又来了，由于我们各种点击、敲击键盘、尝试触发各种操作而产生新的节点，我们该怎么办？
肯定还是要继续处理这些新节点，但是怎么找到这些新节点，难道还要重新再扫一遍 DOM 查找新节点？
有没有一个方法可以获取到变化的属性和节点？</p>
<p>在 HTML5 中就刚好有这么一个类 <code>MutationObserver</code>，我们看看例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">onclick</span>=<span class="string">"createE()"</span>&gt;</span>create element<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn2"</span> <span class="attr">onclick</span>=<span class="string">"changeA()"</span>&gt;</span>change attr<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form1"</span> <span class="attr">action</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    btn1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> eA = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span></span><br><span class="line"><span class="javascript">        eA.href = <span class="string">"http://www.fatezero.org"</span>;</span></span><br><span class="line">        container.appendChild(eA);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    btn2.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        form1.action = <span class="string">"http://www.fatezero.org/form"</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations </span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        mutations.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">mutation</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (mutation.type === <span class="string">'childList'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 在创建新的 element 时调用</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"child list: "</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(mutation);</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutation.type === <span class="string">'attributes'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 在属性发生变化时调用</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"attributes: "</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(mutation);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    observer.observe(<span class="built_in">window</span>.document, &#123;</span></span><br><span class="line"><span class="javascript">        subtree: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        childList: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        attributes: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        attributeFilter: [<span class="string">'src'</span>, <span class="string">'href'</span>, <span class="string">'action'</span>]</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>按顺序点击 btn1 和 btn2 的结果：</p>
<img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/mutation_observer_result.png" width="600">
<p>所以我们完全可以利用 <code>MutationObserver</code> 作深度优先的扫描，如果弹出新的节点，那就优先处理新的节点。每次都是先静态扫描新的节点列表，然后再尝试触发新增节点列表的事件。</p>
<p>但是值得注意的是 <code>MutationObserver</code> 并不会实时将变更元素传回来，而是收集一个时间段的元素再传回来，所以未能及时切换到新的节点继续触发事件也是正常的事情。</p>
<h2 id="0x06-自动填写表单"><a href="#0x06-自动填写表单" class="headerlink" title="0x06 自动填写表单"></a>0x06 自动填写表单</h2><p>OK，事件我们触发了，新节点我们也处理了，这里我们还需要对一些元素进行特殊处理，比如说自动填写表单内的输入元素。</p>
<p>这一小节没什么难度，主要是判定哪些地方该填名字，哪些地方该填邮箱，哪些地方该填号码，
需要根据不同情况输入对应的数据。另外还要注意的是在填写数据的时候还要触发对应的事件，例如填写 <code>&lt;input type=&quot;text&quot;&gt;</code> 的时候，
我们需要把鼠标移动到 <code>input</code> 元素上，对应触发 <code>mouseover</code>、<code>mouseenter</code>、<code>mousemove</code> 消息，
接着要鼠标点击一下输入点，对应 <code>mousedown</code>、<code>mouseup</code>、<code>click</code> 消息，
然后鼠标移开转到其他元素去，对应 <code>mousemove</code>、<code>mouseout</code>、<code>mouseleave</code> 消息。</p>
<p>这里还有个小建议，所有的用户输入都带上一个可识别的词，
例如我们自定义词为 CasterJS，email 处就填写 <code>casterjs @gmail.com</code>， addr 处就写 <code>casterjs road</code>， 至于为什么下一篇再说。 </p>
<h2 id="0x07-CDP"><a href="#0x07-CDP" class="headerlink" title="0x07 CDP"></a>0x07 CDP</h2><p>这一个小结主要和 CDP 相关的 TIP ，使用什么语言操控 CDP 都行，在这里我选择我比较熟悉的 Python 作为解释。</p>
<h4 id="自定义-request"><a href="#自定义-request" class="headerlink" title="自定义 request"></a>自定义 request</h4><p>CDP 在 navigate 的时候并不能直接自定义 request，通俗的讲就是在 navigate 的时候并不能设置 method 和 headers 等信息，
但很明显这个功能对我们的扫描器来说非常重要。幸运的是，虽然 CDP 没有直接支持这样的功能，但可以通过 <code>Network.requestIntercepted</code> 
变向实现这样的功能。</p>
<p>代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_intercepted</span><span class="params">(interceptionId, request, **kwargs)</span>:</span></span><br><span class="line">    headers = request.get(<span class="string">'headers'</span>, &#123;&#125;)</span><br><span class="line">    headers[<span class="string">'Test-key'</span>] = <span class="string">'test-value'</span></span><br><span class="line"></span><br><span class="line">    tab.Network.continueInterceptedRequest(</span><br><span class="line">        interceptionId=interceptionId,</span><br><span class="line">        headers=headers,</span><br><span class="line">        method=<span class="string">'POST'</span>,</span><br><span class="line">        postData=<span class="string">"hello post data: %s"</span> % time.time()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line">tab = browser.new_tab()</span><br><span class="line"></span><br><span class="line">tab.Network.requestIntercepted = request_intercepted</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    tab.Network.setRequestInterception(patterns=[&#123;<span class="string">'urlPattern'</span>: <span class="string">'*'</span>, <span class="string">'resourceType'</span>: <span class="string">'Document'</span>&#125;])</span><br><span class="line"><span class="keyword">except</span> pychrome.exceptions.CallMethodException:</span><br><span class="line">    tab.Network.setRequestInterceptionEnabled(enabled=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">tab.Page.navigate(url=<span class="string">"http://httpbin.org/post"</span>)</span><br><span class="line"></span><br><span class="line">tab.wait(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">result = tab.Runtime.evaluate(expression=<span class="string">"document.documentElement.outerText"</span>)</span><br><span class="line">html_content = result.get(<span class="string">'result'</span>, &#123;&#125;).get(<span class="string">'value'</span>, <span class="string">""</span>)</span><br><span class="line">print(html_content)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"data"</span>: <span class="string">"hello post data: 1521343371.056448"</span>, </span><br><span class="line">  <span class="attr">"files"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"form"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"headers"</span>: &#123;</span><br><span class="line">    <span class="attr">"Accept"</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span>, </span><br><span class="line">    <span class="attr">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, </span><br><span class="line">    <span class="attr">"Connection"</span>: <span class="string">"close"</span>, </span><br><span class="line">    <span class="attr">"Content-Length"</span>: <span class="string">"34"</span>, </span><br><span class="line">    <span class="attr">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="attr">"Test-Key"</span>: <span class="string">"test-value"</span>, </span><br><span class="line">    <span class="attr">"Upgrade-Insecure-Requests"</span>: <span class="string">"1"</span>, </span><br><span class="line">    <span class="attr">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/63.0.3239.150 Safari/537.36"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"json"</span>: <span class="literal">null</span>, </span><br><span class="line">  <span class="attr">"origin"</span>: <span class="string">"1.1.1.1"</span>, </span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h4><p>我们的浏览器是肯定需要加载 css 和 js 的，那其他网络资源如图片、视频等媒体资源是不是可以直接禁止加载？
其实这样做并不合理，直接禁用图片等资源可能会影响到用户代码执行逻辑，例如我们常见的 <code>&lt;img src=1 onerror=alert(1)&gt;</code>，
所以比较好的解决方法就是返回假的媒体资源。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"><span class="keyword">import</span> pychrome.exceptions</span><br><span class="line"></span><br><span class="line">image_raw_response = (<span class="string">'SFRUUC8xLjEgMjAwIE9LCkNvbnRlbnQtVHlwZTogaW1hZ2UvcG5nCgqJUE5HDQoaCgAAAA1JSERSAAAAAQ'</span></span><br><span class="line">                      <span class="string">'AAAAEBAwAAACXbVsoAAAAGUExURczMzP///9ONFXYAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAKSURBVAiZY'</span></span><br><span class="line">                      <span class="string">'2AAAAACAAH0cWSmAAAAAElFTkSuQmCC'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requestIntercepted</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> image_raw_response</span><br><span class="line">    resource_type = kwargs.get(<span class="string">'resourceType'</span>, <span class="string">'other'</span>).lower()</span><br><span class="line">    interception_id = kwargs.get(<span class="string">'interceptionId'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resource_type == <span class="string">'image'</span>:</span><br><span class="line">        tab.Network.continueInterceptedRequest(</span><br><span class="line">            interceptionId=interception_id,</span><br><span class="line">            rawResponse=image_raw_response,</span><br><span class="line">            _timeout=<span class="number">5</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tab.Network.continueInterceptedRequest(</span><br><span class="line">            interceptionId=interception_id,</span><br><span class="line">            _timeout=<span class="number">5</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line">tab = browser.new_tab()</span><br><span class="line"></span><br><span class="line">tab.Network.requestIntercepted = requestIntercepted</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line">tab.Page.enable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    tab.Network.setRequestInterception(patterns=[&#123;<span class="string">'urlPattern'</span>: <span class="string">'*'</span>, <span class="string">'resourceType'</span>: <span class="string">'Image'</span>&#125;])</span><br><span class="line"><span class="keyword">except</span> pychrome.exceptions.CallMethodException:</span><br><span class="line">    tab.Network.setRequestInterceptionEnabled(enabled=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">tab.Page.navigate(url=<span class="string">"https://weibo.com/fatez3r0"</span>)</span><br><span class="line">tab.wait(<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/replace_images.png" width="700">
<h4 id="session-isolate"><a href="#session-isolate" class="headerlink" title="session isolate"></a>session isolate</h4><p>我们的扫描器可能会有使用不同用户信息扫描同一个域名的情况，
我们肯定不希望在同一个 browser 下，不同 tab 的 Cookie 信息等串在一起，
我们希望每个 tab 都有一个隐身模式，每个 tab 都资源互不影响，
比较走运的是 Headless Chrome 刚好有这么一个功能，叫 session isolate ，也是 Headless 模式下独有的功能。</p>
<p>我们看一下 Headless 模式的 session isolate 功能的简单例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line">version_info = browser.version()</span><br><span class="line"></span><br><span class="line">target = pychrome.Tab(webSocketDebuggerUrl=version_info[<span class="string">'webSocketDebuggerUrl'</span>], id=<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">target.start()</span><br><span class="line">tab0 = browser.new_tab(url=<span class="string">"http://httpbin.org/cookies/set?browser=here_is_fate0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 尝试注释下面这行</span></span><br><span class="line">browser_context_id1 = target.Target.createBrowserContext()[<span class="string">'browserContextId'</span>]</span><br><span class="line">target_id1 = target.Target.createTarget(</span><br><span class="line">    url=<span class="string">"http://httpbin.org/cookies"</span>,</span><br><span class="line">    <span class="comment"># 2. 以及这行</span></span><br><span class="line">    browserContextId=browser_context_id1</span><br><span class="line">)[<span class="string">'targetId'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab1 = pychrome.Tab(</span><br><span class="line">    id=target_id1,</span><br><span class="line">    webSocketDebuggerUrl=<span class="string">'ws://127.0.0.1:9222/devtools/page/&#123;&#125;'</span>.format(target_id1)</span><br><span class="line">)</span><br><span class="line">tab1.start()</span><br><span class="line">tab1.Runtime.enable()</span><br><span class="line">print(tab1.Runtime.evaluate(expression=<span class="string">'document.documentElement.outerText'</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'result'</span>: &#123;<span class="string">'type'</span>: <span class="string">'string'</span>, <span class="string">'value'</span>: <span class="string">'&#123;\n  "cookies": &#123;&#125;\n&#125;\n'</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果注释 1、2 两行，运行结果：
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'result'</span>: &#123;<span class="string">'type'</span>: <span class="string">'string'</span>, <span class="string">'value'</span>: <span class="string">'&#123;\n  "cookies": &#123;\n    "browser": "here_is_fate0"\n  &#125;\n&#125;\n'</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以只要每个 tab 都新建一个 <code>BrowserContext</code> 就可以做到互不干扰了，
这也就相当于每个 tab 都是一个独立的隐身模式，能够做到每个 tab 互不影响，
也可以共用一个 <code>BrowserContext</code> 达到共享 cache、cookie 之类信息的功能。</p>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>从 chromium 62 开始存在一个安全问题，在使用 <code>remote-debugging-port</code> 参数的时候可以系统上任意写文件，
我已经提交安全 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=824816" target="_blank" rel="noopener">issue</a> 给 chromium，
可惜撞洞了，有人比我早了一个月提交了<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=813540" target="_blank" rel="noopener">相关漏洞</a>，
所以在选定 chromium 版本的时候要注意跳过这些版本或者自行修复这些问题。</p>
<h2 id="0x08-结合"><a href="#0x08-结合" class="headerlink" title="0x08 结合"></a>0x08 结合</h2><p>讲了那么多，是时候该把所有的东西结合在一起，我们先简单捋一下执行过程：</p>
<ol>
<li>注入 Hook 相关的 JavaScript 代码</li>
<li>使用 TreeWalker 遍历节点，收集节点链接信息，获取静态的节点列表</li>
<li>触发各个节点的相关操作，自动填写表单</li>
<li>MutationObserver 监控动态节点创建，优先处理新节点</li>
</ol>
<p>我们以 <code>http://testphp.vulnweb.com/AJAX/index.php</code> 作为例子跑一遍，看一下我们代码的执行状况，
为了更方便的展示，我将每个节点（触发事件）的处理时间都额外增加了 0.1s，同时也给所有节点都加上了边框，蓝色边框表示正在处理的节点。</p>
<p>测试视频如下：</p>
<video src="http://static.fatezero.org/blog/video/web-scanner-crawler-02/vulnweb_test.mov" type="video/mov" controls="controls" width="100%" height="100%">
</video>

<p>通过加边框和打 log 的方式，我们完全可以一步一步的看着爬虫的操作是否符合我们的预期。这个例子的结果证明了:</p>
<ul>
<li>xhr 的 hook（不被其他 xhr 中断）</li>
<li>事件的触发（新节点的产生）</li>
<li><code>MutationObserver</code> 的监控（正确处理新节点）</li>
<li>图片资源的处理（原始图片被替换）</li>
<li>窗口的处理（没有弹 alert 窗）</li>
</ul>
<p>上面的行为是符合我们的预期的。</p>
<p>目前第一篇和第二篇的内容总算是组合在了一起，成为了一个能够独立运行、测试的组件，该组件所提供的功能就是输入一个 request 相关的信息，返回 response 中所有的链接信息，
如果我们的爬虫存在链接信息漏抓，那很可能就是这部分出问题，所以也只需要调试这部分代码即可，非常方便。</p>
<p>该组件可以通过stdin/stdout、RPC、消息队列等方式传递任务和结果。
可以通过在单台机器上多开 tab 达到纵向扩展，也可以在多台机器上启多个 browser 达到横向扩展，这部分各自有自个的想法，不会就这个方向继续写下去了。</p>
<h2 id="0x09-总结"><a href="#0x09-总结" class="headerlink" title="0x09 总结"></a>0x09 总结</h2><p>至此，Web 漏洞扫描器爬虫中的 <code>Downloader</code> 这部分我已经简单地介绍了一遍，
对照一下我自己的代码，也深知这部分我并没有讲全，因为这部分坑多，内容也乱且多，但是再写下去就真的没完没了，看着累，写着更累，得赶紧切到下一个话题。</p>
<p><a href="#">下一篇</a>，我将会继续介绍爬虫的调度部分以及整体架构。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/15/web-scanner-crawler-03/" class="prev">PREV</a><a href="/2018/03/05/web-scanner-crawler-01/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2019 <a href="http://blog.fatezero.org">fate0</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">apollo</a>.</p></div></footer></div></body></html>