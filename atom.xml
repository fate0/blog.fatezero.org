<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fate0</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.fatezero.org/"/>
  <updated>2018-11-13T03:28:47.692Z</updated>
  <id>http://blog.fatezero.org/</id>
  
  <author>
    <name>fate0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP 运行时漏洞检测</title>
    <link href="http://blog.fatezero.org/2018/11/11/prvd/"/>
    <id>http://blog.fatezero.org/2018/11/11/prvd/</id>
    <published>2018-11-11T10:00:24.000Z</published>
    <updated>2018-11-13T03:28:47.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这片博文将简单的介绍我编写的 PHP 运行时漏洞检测系统 <a href="https://github.com/fate0/prvd" target="_blank" rel="noopener">prvd</a> 的检测逻辑，以及该系统在实际测试中的效果。</p><a id="more"></a><h2 id="0x01-基本知识"><a href="#0x01-基本知识" class="headerlink" title="0x01 基本知识"></a>0x01 基本知识</h2><p>在这里我们先介绍几个常用的词语：</p><ol><li><p>source</p><p> 数据来源点，可以是：</p><ul><li>网络，例如常规的 Web 参数等</li><li>文件系统</li><li>数据库</li><li>等等其他用户可控或者间接可控的地方</li></ul></li><li><p>filter</p><p> 数据过滤处理点，可以是：</p><ul><li>编码解码，例如 <code>base64_decode</code> 等</li><li>常规字符串操作，例如 <code>strtolower</code> 等</li><li>安全过滤，例如 <code>mysqli_escape_string</code> 等</li><li>等等其他会更改字符串内容的地方</li></ul></li><li><p>sink</p><p> 漏洞触发点，可以是：</p><ul><li>操作文件相关行为，例如 <code>file_put_content</code> 等</li><li>操作网络相关函数，例如 <code>curl</code> 等</li><li>操作命令相关行为，例如 <code>system</code> 等</li><li>等等其他危险行为</li></ul></li></ol><p>有些地方既可以是 source 点，也可以是 sink 点，比如说 <code>file_put_content</code> 在参数可控的时候是 sink 点，因为返回的数据也是我们可控的，这里返回的数据也是 source 点。</p><h2 id="0x02-xmark"><a href="#0x02-xmark" class="headerlink" title="0x02 xmark"></a>0x02 xmark</h2><p>我们先简单地介绍一下 <a href="https://github.com/fate0/xmark" target="_blank" rel="noopener">xmark</a>，这是一个 PHP7 扩展，能够直接使用 PHP 代码做到：</p><ul><li>对字符串变量进行打标记</li><li>Hook 绝大多数函数/类</li><li>Hook 部分 opcode</li></ul><p>基于 <a href="https://github.com/fate0/xmark" target="_blank" rel="noopener">xmark</a> 所提供的功能，即便是我们不熟悉 PHP 内部实现，我们也能够很简单的去实现：</p><ul><li>PHP RASP</li><li>PHP 解密工具，例如 <a href="http://ddecode.com/phpdecoder/" target="_blank" rel="noopener">phpdecoder</a></li><li>PHP 运行时漏洞检测</li><li>…</li></ul><p>因为 PHP 并不像 Python、Ruby 等其他语言可以很方便的 Hook 函数、类，所以我们开发了这么一个扩展来完成类似的功能。</p><p>实际上 <a href="https://github.com/fate0/xmark" target="_blank" rel="noopener">xmark</a> 这个项目有不少代码是直接拷贝 <a href="https://github.com/laruence/taint" target="_blank" rel="noopener">taint</a> 的，那为什么要改这样一个轮子呢？</p><ul><li>taint 的 source 点覆盖不全面，只对 GPC 进行标记</li><li>taint 处理和漏洞相关的逻辑需要在 PHP 扩展中实现</li></ul><p>这里我不打算花太多篇幅介绍 xmark 的实现，直接看代码更方便，更多关于 xmark 的信息可以点<a href="https://github.com/fate0/xmark" target="_blank" rel="noopener">这里</a></p><h2 id="0x03-prvd"><a href="#0x03-prvd" class="headerlink" title="0x03 prvd"></a>0x03 prvd</h2><p>前面说了基于 <a href="https://github.com/fate0/xmark" target="_blank" rel="noopener">xmark</a> 我们可以实现挺多好玩的事情，这里我选择去完成一个 PHP 运行时漏洞检测系统，也就是 <a href="https://github.com/fate0/prvd" target="_blank" rel="noopener">prvd</a> 这个项目，项目名也就是 PHP Runtime Vulnerability Detection 的缩写。</p><p>prvd 有两种模式，一种是 taint 模式, 另外一种是 payload 模式。taint 模式可以选择开启，payload 模式是一直都开启的。这两种模式都依赖外部来解决执行路径的问题。</p><h4 id="taint-模式"><a href="#taint-模式" class="headerlink" title="taint 模式"></a>taint 模式</h4><p>这种模式下 prvd 和 taint 一样，都是 source 打上一个标记，在某些 filter 中传递这个标记，然后在 sink 点检查对应的参数是否被打上标记。</p><p>比方说：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$cmd = $_POST[<span class="string">'cmd'</span>];</span><br><span class="line">$cmd1 .= <span class="string">"fate0"</span>;</span><br><span class="line">$cmd2 = strtolower($cmd1);</span><br><span class="line">system($cmd2);</span><br></pre></td></tr></table></figure></p><p><code>$_POST[&#39;cmd&#39;]</code> 一开始就被我们打上了标记，在自赋值的时候将标记传递给了 <code>$cmd1</code>，在经历 <code>strtolower</code> 这个 filter 的时候继续将标记传递给了 <code>$cmd2</code>，<code>$cmd2</code> 最后进入 sink 点 <code>system</code> 函数的时候被检测被打上了标记，从而确定是否可能存在问题。</p><p>taint 模式可以不需要输入特定的 payload 进行攻击就可能发现一些漏洞点，也不会污染数据，但是在 filter 中判断是否应该继续传递标记比较难处理，有可能数据已经经过了很好的过滤，但是我们还是继续传递了标记，最终导致误报。也有可能数据处理不当，但我们已经去除了标记，最终导致漏报。</p><p>我们举个漏报的例子：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$id = $_POST[ <span class="string">'id'</span> ];</span><br><span class="line"></span><br><span class="line">$id = mysqli_real_escape_string($GLOBALS[<span class="string">"___mysqli_ston"</span>], $id);</span><br><span class="line"></span><br><span class="line">$query  = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = $id;"</span>;</span><br><span class="line"><span class="comment">// $query  = "SELECT first_name, last_name FROM users WHERE user_id = '$id';";</span></span><br><span class="line">$result = mysqli_query($GLOBALS[<span class="string">"___mysqli_ston"</span>], $query) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysqli_error($GLOBALS[<span class="string">"___mysqli_ston"</span>]) . <span class="string">'&lt;/pre&gt;'</span> );</span><br></pre></td></tr></table></figure></p><p>可控变量 <code>$id</code> 经过 <code>mysqli_real_escape_string</code> 的时候需不需清除其标记呢？</p><p>为了解决这种情况，我编写了另外一种 payload 模式。</p><h4 id="payload-模式"><a href="#payload-模式" class="headerlink" title="payload 模式"></a>payload 模式</h4><p>有时候追踪执行流并没有什么用，整那么多玩意，还不如直接一把梭哈，直接把 payload 打过去，然后在 sink 点观测，这就是我们的 payload 模式，这个模式的 prvd 可以归类为 IAST 的一种。</p><p>payload 模式相比 taint 模式，优点为：</p><ul><li>误报率比 taint 模式低，使用 payload 模式，从技术上完全把误报率降低到 1% 以下</li><li>可以不关注 source 点和 filter 点，这样即使数据经历多次中转，最后经过 sink 点的漏洞，也有能力去检测，比如说多阶 SQL 注入的情况</li></ul><p>缺点为：</p><ul><li>漏报率可能会比 taint 模式下高，因为可能经过各种 filter 的时候就被 payload 就会拦截下来，也可能需要特定 payload 才能触发漏洞</li><li>需要特别关注 sink 点，在 sink 点中根据各种条件判断是否为漏洞</li><li>会污染数据</li></ul><p>下面简单的介绍一下在 payload 模式下，各种漏洞的检测方法：</p><table><thead><tr><th>漏洞类型</th><th>检测方法</th></tr></thead><tbody><tr><td>SQL 注入</td><td>在 <code>prvd_check_sqli</code> 中检测待 SQL 的完整性是否被破坏，是否逃逸了单双引号</td></tr><tr><td>任意文件操作</td><td>在 <code>prvd_check_path</code> 中检测文件操作的路径中是否包含 <code>../xtanzi</code> 字符串</td></tr><tr><td>远程命令执行</td><td>在 <code>prvd_check_rce</code> 中检测待执行命令的完整性是否破坏，是否逃逸了单双引号</td></tr><tr><td>SSRF</td><td>在 <code>prvd_check_ssrf</code> 中检测输入的链接 domain 是否包含 <code>xtanzi</code> 字符串</td></tr><tr><td>XSS</td><td>在 <code>prvd_check_xss</code> 中判断输入是否被 taint 标记</td></tr><tr><td>调用任意 callback</td><td>在 <code>prvd_check_callback</code> 中检测 callback 是否包含 <code>xtanzi</code> 字符串</td></tr></tbody></table><p>我知道上面的各种检测方式并不完美，每个漏洞的检测方法都有误报和漏报的情况，不过现阶段还是够用的，可以以后继续完善。</p><h4 id="fuzzer"><a href="#fuzzer" class="headerlink" title="fuzzer"></a>fuzzer</h4><p>这里我使用 Python 写了一个比较简单的 fuzzer 放在项目 tools 目录下，目前也只是对每个 source 点增加一个 <code>&#39;&quot;&gt;&lt;xtanzi&gt;./../xtanzi</code> 这样的 payload</p><p>这个 fuzzer 的 DSN 地址为 <a href="http://admin:password@ip:9090/fuzz" target="_blank" rel="noopener">http://admin:password@ip:9090/fuzz</a></p><p>这里也可以根据自己的情况，重新编写 fuzzer。</p><h4 id="Sentry-漏洞展示"><a href="#Sentry-漏洞展示" class="headerlink" title="Sentry 漏洞展示"></a>Sentry 漏洞展示</h4><p>至此，我们还缺少一个漏洞上报的平台，我们希望这个平台能够：</p><ul><li>良好的权限管理，拥有的 group、project 等功能</li><li>收集到漏洞触发时的请求信息</li><li>收集到漏洞触发时的堆栈信息</li><li>能够对多个同堆栈下的重复漏洞进行去重</li><li>能够一键提交 jira 以及 git issue</li><li>各种统计功能</li><li>…</li></ul><p>天啊，需求越来越多，我们的精力更多的被分配到了这个平台上了，请不要忘了我们本意是要做一个 PHP 运行时漏洞检测系统。上报平台虽然重要，但不应该成为整套系统花费精力最多的部分，我们需要把时间放在漏洞检测这块。</p><p>这个时候我想起了 <a href="https://github.com/getsentry/sentry" target="_blank" rel="noopener">Sentry</a></p><blockquote><p>Sentry is cross-platform application monitoring, with a focus on error reporting. </p></blockquote><img src="http://static.fatezero.org/blog/img/prvd/sentry.png"><p>Sentry 本来是一个跨平台应用的异常报告系统，但在我们这套 PHP 运行时漏洞检测系统中被使用为漏洞上报平台了，理由是：</p><ul><li>支持上面提到的需求</li><li>界面美观</li><li>DRY</li></ul><p>我们的 prvd 可以说是 Sentry 的一个检测漏洞的 Client，只不过 prvd 的功能不是报告异常，而是报告漏洞，由于 Sentry 支持多种语言，所以我们不仅可以给 PHP 写这样一个 Client，还可以给 Python, Ruby 等其他语言写这样检测漏洞的 Client</p><h2 id="0x04-实际例子"><a href="#0x04-实际例子" class="headerlink" title="0x04 实际例子"></a>0x04 实际例子</h2><p>最后，我们拿 <a href="http://updatenew.dedecms.com/base-v57/package/DedeCMS-V5.7-UTF8-SP2.tar.gz" target="_blank" rel="noopener">DedeCMS</a> 作为测试例子，看看 prvd 的效果如何。</p><h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><p>首先在 <code>dede/config.php</code> 修改 <code>csrf_check</code> 函数让其直接返回 true，其次执行下面命令启动 fuzzer：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python prvd/tools/fuzzer.py</span><br></pre></td></tr></table></figure><p>然后前往 <a href="https://sentry.io" target="_blank" rel="noopener">Sentry</a> 注册一个账号，或者自建一套 Sentry 服务</p><p>剩下的可以直接使用 docker</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line">docker pull fate0/prvd</span><br><span class="line">docker run -d --name dede_mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=1 -e MYSQL_ROOT_PASSWORD=<span class="string">''</span> -p 3306:3306 mysql --default-authentication-plugin=mysql_native_password</span><br><span class="line">docker run -d --name dede_prvd -e <span class="string">"PRVD_SENTRY_DSN=&#123;SENTRY_DSN&#125;"</span> -e <span class="string">"PRVD_FUZZER_DSN=&#123;FUZZER_DSN&#125;"</span> -e <span class="string">"PRVD_TAINT_ENABLE=false"</span> -v <span class="string">"/local_path_to_web_root/:/var/www/html"</span> -p 8080:80 --link dede_mysql fate0/prvd</span><br></pre></td></tr></table></figure><p>因为 taint 模式误报会比较多(taint 模式出来的漏洞在 Sentry 上会以蓝色标注)，我也并不打算花时间去 review 详情，所以这里我只启用了 payload 模式。</p><h4 id="检测过程"><a href="#检测过程" class="headerlink" title="检测过程"></a>检测过程</h4><p>每个功能点都乱点一下，每个输入框都随便写写，尽量每个功能都能够瞎点瞎填覆盖到。</p><h4 id="DedeCMS-相关漏洞"><a href="#DedeCMS-相关漏洞" class="headerlink" title="DedeCMS 相关漏洞"></a>DedeCMS 相关漏洞</h4><p>最后得出下面这些可疑的漏洞：</p><ul><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_archives_do.php_sqli.html" target="_blank" rel="noopener">dede_archives_do.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_article_add.php_body_sqli.html" target="_blank" rel="noopener">dede_article_add.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_article_keywords_make.php_sqli.html" target="_blank" rel="noopener">dede_article_keywords_make.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_article_test_same.php_sqli.html" target="_blank" rel="noopener">dede_article_test_same.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_pm.php_sqli.html" target="_blank" rel="noopener">dede_pm.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_makehtml_rss_action.php_sqli.html" target="_blank" rel="noopener">dede_makehtml_rss_action.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_co_gather_start_action.php_sqli.html" target="_blank" rel="noopener">dede_co_gather_start_action.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_co_export.php_sqli.html" target="_blank" rel="noopener">dede_co_export.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_co_do.php_sqli.html" target="_blank" rel="noopener">dede_co_do.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_content_batchup_action.php_sqli.html" target="_blank" rel="noopener">dede_content_batchup_action.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_makehtml_all.php_sqli.html" target="_blank" rel="noopener">dede_makehtml_all.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_makehtml_archives_action.php_sqli_1.html" target="_blank" rel="noopener">dede_makehtml_archives_action.php SQL 注入</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_article_add.php_ssrf.html" target="_blank" rel="noopener">dede_article_add.php 服务器端请求伪造</a></li><li><a href="http://static.fatezero.org/blog/other/prvd/dedecms_co_add.php_ssrf.html" target="_blank" rel="noopener">dede_co_add.php 服务器端请求伪造</a></li><li>…</li></ul><p>虽然都只是后台的漏洞，但拿来做演示是最好不过了 ：）</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>上面简单的介绍了 prvd 的检测原理和使用过程。简单的说，prvd 就是一个半自动的 PHP 运行时漏洞检测系统，在 taint 模式下，会尽可能显示可疑漏洞，方便熟悉安全的人员或者开发人员去 review 代码，在 payload 模式下，即使不太了解安全的测试人员也能够检测出漏洞。</p><h2 id="0x06-引用"><a href="#0x06-引用" class="headerlink" title="0x06 引用"></a>0x06 引用</h2><ul><li><a href="https://github.com/fate0/prvd" target="_blank" rel="noopener">prvd</a></li><li><a href="https://github.com/laruence/taint" target="_blank" rel="noopener">taint</a></li><li><a href="https://github.com/fate0/xmark" target="_blank" rel="noopener">xmark</a></li><li><a href="https://github.com/getsentry/sentry" target="_blank" rel="noopener">Sentry</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;这片博文将简单的介绍我编写的 PHP 运行时漏洞检测系统 &lt;a href=&quot;https://github.com/fate0/prvd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;prvd&lt;/a&gt; 的检测逻辑，
以及该系统在实际测试中的效果。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>爬虫调度篇[Web 漏洞扫描器]</title>
    <link href="http://blog.fatezero.org/2018/04/15/web-scanner-crawler-03/"/>
    <id>http://blog.fatezero.org/2018/04/15/web-scanner-crawler-03/</id>
    <published>2018-04-15T10:00:24.000Z</published>
    <updated>2018-11-13T03:28:47.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p><a href="http://blog.fatezero.org/2018/03/05/web-scanner-crawler-02/">上一篇</a>主要如何通过向浏览器页面注入 JavaScript 代码来尽可能地获取页面上的链接信息，最后完成一个稳定可靠的单页面链接信息抓取组件。这一篇我们跳到一个更大的世界，看一下整个漏扫爬虫的运转流程，这一篇会着重描写爬虫架构设计以及调度部分。</p><a id="more"></a><h2 id="0x01-设计"><a href="#0x01-设计" class="headerlink" title="0x01 设计"></a>0x01 设计</h2><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-03/scrapy_architecture_02.png"><p>这张图片是不是很熟悉，其实这就是 <code>Scrapy</code> 的架构设计图，我们简单看一下这张图的流程：</p><ol><li><code>Engine</code> 拿到 <code>Requests</code></li><li><code>Engine</code> 将 <code>Requests</code> 丢到 <code>Scheduler</code> 中，并向 <code>Scheduler</code> 请求下一个准备抓取的 <code>Request</code></li><li><code>Scheduler</code> 返回下一个准备抓取的 <code>Request</code></li><li><code>Engine</code> 将 <code>Request</code> 丢到 <code>Downloader</code> 中，中途经过 <code>Downloader Middlewares</code> 处理</li><li><code>Downloader</code> 处理 <code>Request</code> 产生 <code>Response</code> 返回给 <code>Engine</code>，中途经过 <code>Downloader Middlewares</code> 处理</li><li><code>Engine</code> 将 <code>Response</code> 丢到 <code>Spider</code> 中，中途经过 <code>Spider Middleware</code> 处理</li><li><code>Spider</code> 处理 <code>Response</code> 产生出 <code>item</code> 和新的 <code>Requests</code> 返回给 <code>Engine</code>，中途经过 <code>Spider Middleware</code> 处理</li><li><code>Engine</code> 将 <code>item</code> 丢到 <code>Item Pipelines</code> 处理，同时将 <code>Requests</code> 丢到 <code>Scheduler</code> 中</li><li>重复 1-8 步骤，直到 <code>Scheduler</code> 没有新的 <code>Requests</code></li></ol><p>在整体架构上我直接参考了 <code>Scrapy</code> 的设计，只不过我实在受不了 <code>Twisted</code> 那种扭曲的写法，所以直接换了个网络库重新造了个和 <code>Scrapy</code> 差不多的轮子，新的架构图如下：</p><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-03/caster_spider_architecture.png"><p>上面架构图中消息队列(<code>MQ</code>)左边的内部名为 <code>CasterPy</code>，右边的内部名为 <code>CasterJS</code>， 我们前两篇主要介绍的单页面链接信息抓取组件(<code>CasterJS</code>)就是上面的架构设计中的 <code>Downloader</code>，我们的架构设计和 <code>Scrapy</code> 的区别是：</p><ul><li>我们的 <code>Downloader</code> 直接返回链接信息而不是返回响应内容</li><li>我们的 <code>Downloader</code> 是分布式的，可部署在不同的服务器上</li><li>我们的 <code>Engine</code> 通过消息队列与 <code>Downloader</code> 通信</li><li>我们的 <code>Downloader</code> 针对同一个站点并发数始终为 1</li><li>我们的 <code>CasterPy</code> 使用协程同时处理多个站点，可同时和多个 <code>Downloader</code> 进行通信</li></ul><p>我们的 <code>Spider</code> 组件也只是简单的解析链接信息返回相对应的 <code>item</code> 和新的 <code>Request</code>，这部分没什么好讲的，我们的 <code>Engine</code> 组件和 <code>Scrapy</code> 的也差不多，就是 <code>Item</code>、<code>Request</code>、<code>Response</code> 的搬运工，这部分也不用细讲，至于 <code>Item Pipelines</code>，最后数据怎么存储、存储到哪里去，每家公司都有自己的想法（每家公司的想法差距都挺大的），这个就仁者见仁，剩下就只有 <code>Scheduler</code> 了。</p><h2 id="0x02-调度"><a href="#0x02-调度" class="headerlink" title="0x02 调度"></a>0x02 调度</h2><p><code>Scheduler</code> 决定了 <code>Request</code> 的优先级、去留，漏扫爬虫的 <code>Scheduler</code> 和普通爬虫的 <code>Scheduler</code> 最大的区别是如何决定 <code>Request</code> 的去留，也就是爬虫的去重问题。</p><p>去重真的是我在写漏扫爬虫除了 <code>QtWebkit</code> 之外最头疼的事情了。针对漏扫爬虫的去重，完全就没有什么比较好的公开的策略去处理，老生常谈的 <code>Bloom Filter</code> 在漏扫爬虫中毫无用武之地。</p><p>普通爬虫一般来说只会丢弃非目标、已爬取的 <code>Request</code>，但在漏扫爬虫中完全不能只做这些，因为这样不仅会浪费爬虫的资源，也会浪费后续检测的资源，所以我们需要自己造一个去重策略对 <code>Request</code> 进行更深层次的去重。</p><h4 id="资源去重"><a href="#资源去重" class="headerlink" title="资源去重"></a>资源去重</h4><p>我们在使用 Chromium 加载一个页面的时候，Chromium 会对网络资源做分类，这些分类主要有：</p><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-03/chromium_resource_type.png" width="500"><p>我们在之前注入的 JavaScript 代码在获取链接信息的时候也采取了这样的分类(虽然我之前没讲=。=)，那很明显，我们只需要对 <code>Doc</code> 类型的 <code>Request</code> 进行再入 download 队列，其他资源都没必要再使用浏览器再下载渲染一遍。</p><h4 id="链接去重"><a href="#链接去重" class="headerlink" title="链接去重"></a>链接去重</h4><p>在最初的几年前在头疼去重这个问题的时候，剑心和我讨论的结果是可以把 request 中的参数分为 <code>action</code> 类型和 <code>data</code> 类型：</p><ul><li><code>action</code> 类型: 对代码逻辑产生影响的参数</li><li><code>data</code> 类型: 在代码中作为数据使用，一般不会影响到代码逻辑的参数</li></ul><p>简单的讲，<code>action</code> 类型的参数就是语言 vm 中 opcode，<code>data</code> 类型就是语言 vm 中的操作数，我们就是希望能够从 request 数据中分析出哪些是 <code>action</code> 类型的参数，哪些是 <code>data</code> 类型的参数，然后再进行去重。</p><p>我们看个简单的例子：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'a'</span>] == <span class="string">'create'</span>) &#123;</span><br><span class="line">    mysql_query(<span class="string">"INSERT INTO test VALUES ('$_GET['b']')"</span>, $conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>a</code> 就是属于 <code>action</code> 类型的参数，因为 <code>a</code> 的值必须是 <code>create</code> 才会有数据库操作的逻辑。<code>b</code> 属于 <code>data</code> 类型的参数，因为 <code>b</code> 的值无关紧要，不会影响到代码执行逻辑。</p><p>从代码中很容易分析出参数的类型，可是仅仅从 url 中怎么区别参数类型呢？这个时候我们就需要从开发人员写代码的心理去推测参数类型了。</p><p>首先一般开发人员不会使用中文作为 <code>action</code> 类型参数的值，很难想象会有人这样写代码：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'a'</span>] == <span class="string">'创建'</span>) &#123; <span class="comment">/* do create stuff */</span>&#125;</span><br></pre></td></tr></table></figure></p><p>所以带中文字符的参数，可以直接被认为是 <code>data</code> 类型的参数。</p><p>其次一般开发人员的不会使用超过 2 位的纯数字作为 <code>action</code> 类型的值：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'a'</span>] == <span class="string">'87'</span>) &#123; <span class="comment">/* do create stuff */</span> &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ($_GET[<span class="string">'a'</span>] == <span class="string">'9527'</span>) &#123; <span class="comment">/*do delete stuff */</span> &#125;</span><br></pre></td></tr></table></figure></p><p>再次一般开发人员也不会使用 HASH/UUID 值作为 <code>action</code> 类型的值：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'a'</span>] == <span class="string">'f95df1d4d3c89392f1fd920787bb7303'</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ($_GET[<span class="string">'a'</span>] == <span class="string">'f95df1d4-d3c8-9392-f1fd-920787bb7303'</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>还记得<a href="">上一篇</a>我们提到自动化填写表单的时候，最好能够自定义输入的地方都填上带 <code>casterjs</code> 字符吗？就是为了能够在这里直接区分出带 <code>casterjs</code> 值的参数都是 <code>data</code> 类型参数。</p><p>最后一般开发人员也不会使用 … (自由想象、发挥、总结规律)</p><p>其实我们这个过程就是在猜，猜测一个正常的开发人员的编码规范。前期通过各种猜测，我们可以对下面这些类型的 url 简单去重：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://fatezero.org/test?a=create&amp;b=你好</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=3721</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=casterjs@gmail.com</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=f95df1d4d3c89392f1fd920787bb7303</span><br></pre></td></tr></table></figure><p>因为上面的参数 <code>b</code> 被识别成 <code>data</code> 类型参数，所以理论上 <code>b</code> 的值被替换成什么都无所谓，我们将 <code>data</code> 类型参数的值替换成 <code>{ { data }}</code> 得到 “临时规则”：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://fatezero.org/test?a=create&amp;b=&#123;&#123;data&#125;&#125;</span><br></pre></td></tr></table></figure><p>上面这些去重步骤仅仅是第一步，接下来我们还要考虑下面这种情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://fatezero.org/test?a=create&amp;b=halo</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=hello</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=你好</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=3721</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=casterjs@gmail.com</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=f95df1d4d3c89392f1fd920787bb7303</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过第一步简单替换之后，得到 “临时规则”：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. http://fatezero.org/test?a=create&amp;b=halo</span><br><span class="line">2. http://fatezero.org/test?a=create&amp;b=hello</span><br><span class="line">3. http://fatezero.org/test?a=create&amp;b=&#123;&#123;data&#125;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这样的结果我们并不是特别满意，但通过第一步简单替换也只能得到这样的结果了。但随着第三条 “临时规则” 命中的 url 越来越多，我们就越有理由相信参数 <code>b</code> 就是 <code>data</code> 类型的参数，参数 <code>a</code> 就是 <code>action</code> 类型的参数，所以刚刚得到的 “临时规则” 在命中次数达到我们所设定的一个阈值后，还可以变成 “最后规则” ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://fatezero.org/test?a=create&amp;b=&#123;%data%&#125;</span><br></pre></td></tr></table></figure><p>上面这条就是去重过程中生成的去重 “最后规则”，根据这条 “最后规则” 我们又可以直接对下面的链接直接去重：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://fatezero.org/test?a=create&amp;b=nihao</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=world</span><br><span class="line">http://fatezero.org/test?a=create&amp;b=create</span><br></pre></td></tr></table></figure></p><p>“临时规则” 只有统计的作用，并不能参与去重复步骤，但是 “最后规则” 可以参与去重。就如同刚才所示，”临时规则” 可以发展成 “最后规则”。在 <code>Scheduler</code> 去重中，我们最希望拿到的并不是 url，而是实时在变化的去重规则，通过越来越多的 url 生成越来越精准的去重规则，再通过越来越精准的规则反过来再对以后以及之前的 url 进行去重，得到重复度越来越低的 url，这就是我们造的去重策略。</p><h4 id="URL-Rewrite-去重"><a href="#URL-Rewrite-去重" class="headerlink" title="URL Rewrite 去重"></a>URL Rewrite 去重</h4><p>前面我们根据猜测开发人员心理去制定去重策略，这里我们还需要继续猜测 URL Rewrite 配置人员的心理去完善我们的去重策略。</p><p>我们先看一下几种常规的 URL Rewrite 之后 url 的样子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://fatezero.org/view/123.html</span><br><span class="line">http://fatezero.org/view-123.html</span><br><span class="line">http://fatezero.org/view_123.html</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们先假设上面的 <code>view</code> 就是我们所说的 <code>action</code> 类型参数，<code>123</code> 就是 <code>data</code> 类型参数，针对 URL Rewrite 之后的 url，我们首先应该找到各个参数之间的间隔符号是什么，上面的例子中参数间隔符号分别是 <code>/</code>、<code>-</code>、<code>_</code>，然后以根路径开始，用 1、2、3 顺序作为 key，对应 path 深度的值作为 value，最终还是可以直接转换成 <code>key-value</code> 格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://fatezero.org/?1=view&amp;2=123</span><br></pre></td></tr></table></figure><p>最后还是通过之前的去重策略进行去重，发现了么，漏扫去重这块大多数时候都只能猜测，并没有一个万能的解决方法。</p><h2 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a>0x03 测试</h2><p>经过简单的测试，在 2 核 4G 内存服务器上能同时跑 50 个 Chromium Tab，在 4 核 8G 内存服务器上一个 <code>CasterPy</code> 能够同时跑 1000 个任务，也就是说一台 <code>CasterPy</code> 服务器可以和 20 台 <code>CasterJS</code> 服务器构成一个小规模的爬虫。如果任务并发数增加，那也得相对应增加 <code>CasterPy</code> 服务器的资源以及 <code>CasterJS</code> 服务器的数量了。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>至此，扫描器中爬虫部分就算简单地过了一遍，虽然讲得比较粗略，但不管怎么样也得切到下一个话题了。</p><p><a href="#">下一篇</a>我们讲一下 Web 漏洞扫描器中漏洞检测技巧部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://blog.fatezero.org/2018/03/05/web-scanner-crawler-02/&quot;&gt;上一篇&lt;/a&gt;主要如何通过向浏览器页面注入 JavaScript 代码来尽可能地获取页面上的链接信息，最后完成一个稳定可靠的单页面链接信息抓取组件。这一篇我们跳到一个更大的世界，看一下整个漏扫爬虫的运转流程，这一篇会着重描写爬虫架构设计以及调度部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web 漏洞扫描器" scheme="http://blog.fatezero.org/tags/Web-%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>爬虫 JavaScript 篇[Web 漏洞扫描器]</title>
    <link href="http://blog.fatezero.org/2018/04/09/web-scanner-crawler-02/"/>
    <id>http://blog.fatezero.org/2018/04/09/web-scanner-crawler-02/</id>
    <published>2018-04-09T10:00:24.000Z</published>
    <updated>2018-11-13T03:28:47.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p><a href="http://blog.fatezero.org/2018/03/05/web-scanner-crawler-01/">上一篇</a>主要讲了如何通过修改 Chromium 代码为 Web 漏洞扫描器的爬虫打造一个稳定可靠的 headless 浏览器。这一篇我们从浏览器底层走到上层，从 C++ 切换到 JavaScript，讲一下如何通过向浏览器页面注入 JavaScript 代码来尽可能地获取页面上的链接信息。</p><a id="more"></a><h2 id="0x01-注入-JavaScript-的时间点"><a href="#0x01-注入-JavaScript-的时间点" class="headerlink" title="0x01 注入 JavaScript 的时间点"></a>0x01 注入 JavaScript 的时间点</h2><p>首先我们要解决的第一个问题是：在什么时间点向浏览器页面注入 JavaScript 代码？</p><p>答案非常简单，在页面加载前，我们希望能够注入一段 JavaScript 代码以便于能够 Hook、备份各种未被污染的函数，在页面加载后，我们希望能够注入一段 JavaScript 代码以便于能够进行遍历各个元素、触发各种事件、获取链接信息等操作。</p><p>那么下一个问题又来了：怎么定义页面加载前、页面加载后？</p><p>页面加载前的定义非常简单，只要能在用户代码执行前执行我们注入的 JavaScript 代码即可，也就是在页面创建之后、用户代码执行之前的时间段对于我们来说都算是页面加载前，CDP 刚好提供了这么一个 API <a href="https://chromedevtools.github.io/devtools-protocol/tot/Page#method-addScriptToEvaluateOnNewDocument" target="_blank" rel="noopener"><code>Page.addScriptToEvaluateOnNewDocument</code></a> 能够让我们在页面加载前注入 JavaScript 代码。</p><p>接下来考虑一下该如何定义页面加载后。最简单的方法就是不管三七二一，每个页面都加载 30s (即便是空白的页面)，随后再注入我们的代码，但很明显这会浪费很多资源，我们需要根据每个页面的复杂度来控制加载时间。可能会有同学说我们可以监听 <code>load</code> 事件，等待页面加载结束之后再注入代码，那我们考虑一个比较常见的场景，在某个页面上刚好有那么一两个图片字体资源加载速度特别慢，导致 <code>load</code> 迟迟未被触发(甚至不触发)，但这些资源其实我们并不在乎，完全可以直接注入我们代码，所以只等待 <code>load</code> 事件也并不是一个特别好的选择。</p><p>我们先看一下加载一个页面的过程，除了会触发 <code>load</code> 事件之外还会触发什么事件:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在外部 script 之前的 css 会阻塞 DOM 的构建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://httpbin.org/delay/3?id=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://httpbin.org/delay/1?id=2"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 后面两个 css 并不会阻塞 DOM 的构建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://httpbin.org/delay/6?id=3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://httpbin.org/delay/6?id=4"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"><span class="keyword">import</span> pychrome.exceptions</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lifecycleEvent</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"&#123;&#125;: &#123;&#125;"</span>.format(kwargs[<span class="string">'timestamp'</span>], kwargs[<span class="string">'name'</span>]))</span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line">tab = browser.new_tab()</span><br><span class="line"></span><br><span class="line">tab.Page.lifecycleEvent = lifecycleEvent</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line">tab.Page.enable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    tab.Page.setLifecycleEventsEnabled(enabled=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">except</span> pychrome.exceptions.CallMethodException:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">tab.Page.navigate(url=<span class="string">"http://localhost/load_event.html"</span>)</span><br><span class="line">tab.wait(<span class="number">60</span>)</span><br></pre></td></tr></table></figure><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/carbon.png" width="350"><p>下面我们简单地介绍一下上面几个我们会用到的事件</p><table><thead><tr><th>事件</th><th>解释</th></tr></thead><tbody><tr><td>DOMContentLoaded</td><td>一般表示 DOM 和 CSSOM 均准备就绪的时间点</td></tr><tr><td>networkAlmostIdle</td><td>当前网络连接数少于 2 后触发</td></tr><tr><td>networkIdle</td><td>当前没有网络连接后触发</td></tr><tr><td>load</td><td>网页所有资源载入后触发，浏览器上加载转环停止旋转</td></tr></tbody></table><p>之前解释过 <code>load</code> 事件可能对我们来说太晚了，但是现在 <code>DOMContentLoaded</code> 事件对我们来说又太早了，因为用户代码也可能会绑定这个事件然后操作 DOM，我们肯定是希望能够在页面稳定之后再注入我们的代码，所以在 <code>load</code> 和 <code>DOMContentLoaded</code> 之间某个时间点对我们来说比较合适，可惜并没有这样一个特别的事件存在，所以我个人觉得比较好的方案是将上面各个事件结合一起使用。</p><p>我们先说一下这几个事件的触发顺序，首先这几个事件触发顺序不一定，例如触发时间 <code>load</code> 事件不一定比 <code>DOMContentLoaded</code> 晚，<code>load</code> 也不一定比 <code>networkAlmostIdle</code> 晚。唯一能确定的就是 <code>networkAlmostIdle</code> 一定比 <code>networkIdle</code> 晚。在一般的情况下时间顺序是 <code>DOMContentLoaded</code> -&gt; <code>networkAlmostIdle</code> -&gt; <code>networkIdle</code> -&gt; <code>load</code>。</p><p>所以一般的解决方案：</p><ol><li>等待 <code>load</code>，同时设定等待超时时间，<code>load</code> 超时直接注入代码，同时等待 <code>DOMContentLoaded</code> 事件</li><li><code>DOMContentLoaded</code> 事件触发，接着等待 <code>networkAlmostIdle</code>，同时设定等待超时时间，超时直接注入代码</li><li><code>networkAlmostIdle</code> 事件触发，接着等待 <code>networkIdle</code> 同时设定等待超时时间，超时直接注入代码</li></ol><p>如果 <code>load</code> 事件在其他事件前触发，那就直接注入代码。</p><h2 id="0x02-DOM-构建前"><a href="#0x02-DOM-构建前" class="headerlink" title="0x02 DOM 构建前"></a>0x02 DOM 构建前</h2><p>解决了在什么时候注入 JavaScript 代码的问题，接下来我们该开始考虑第一阶段该注入什么代码了。</p><p>由于在第一阶段的时间点，DOM 树还未构建，所以我们所注入的代码均不能操作 DOM，能干的事情也就只有 Hook、备份 BOM 中的函数。</p><h4 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h4><p>我们先把一些会导致页面阻塞、关闭的函数给 Hook 了，例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="built_in">window</span>.prompt = <span class="function"><span class="keyword">function</span> (<span class="params">msg, input</span>) </span>&#123; <span class="keyword">return</span> input; &#125;;</span><br><span class="line"><span class="built_in">window</span>.confirm = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;;</span><br><span class="line"><span class="built_in">window</span>.close = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br></pre></td></tr></table></figure><p>同时也需要在 CDP 中处理 <code>Page.javascriptDialogOpening</code> 事件，因为还有类似 <code>onbeforeunload</code> 这样的弹窗。</p><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>还记得我们上一篇通过修改 Chromium 代码将 <code>location</code> 变成可伪造的事情了吗？就是为了能够在这里对 <code>location</code> 直接 Hook，直接看代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oldLocation = <span class="built_in">window</span>.location;</span><br><span class="line"><span class="keyword">var</span> fakeLocation = <span class="built_in">Object</span>();</span><br><span class="line">fakeLocation.replace = fakeLocation.assign = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + value);</span><br><span class="line">&#125;;</span><br><span class="line">fakeLocation.reload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">fakeLocation.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> oldLocation.toString();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(fakeLocation, &#123;</span><br><span class="line">    <span class="string">'href'</span>: &#123;</span><br><span class="line">        <span class="string">'get'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oldLocation.href; &#125;,</span><br><span class="line">        <span class="string">'set'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + value); &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// hash, host, hostname ...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> replaceLocation = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">'location'</span>, &#123;</span><br><span class="line">        <span class="string">'get'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> fakeLocation; &#125;,</span><br><span class="line">        <span class="string">'set'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + value); &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">replaceLocation(<span class="built_in">window</span>);</span><br><span class="line">addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    replaceLocation(<span class="built_in">document</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里还需要注意的是 <code>doucment.location</code> 需要等待 DOM 构建结束之后才能 hook, 所以需要注册 <code>DOMContentLoaded</code> 事件来 hook <code>document.location</code>。</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>因为之前我们修改了 <code>Chromium</code> 代码使得 <code>window.open</code> 无法新建窗口，这样在 CDP 中也没法获取 <code>window.open</code> 想打开的链接信息，所以我们还需要在代码中 Hook <code>window.open</code> 函数：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + url); &#125;;</span><br></pre></td></tr></table></figure></p><p>还有我们比较常用的 AJAX：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.XMLHttpRequest.prototype.send = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录发送的数据，注意 data 可能是 raw data </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.XMLHttpRequest.prototype.open = <span class="function"><span class="keyword">function</span> (<span class="params">method, url, async, user, password</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录 method, url 等信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.XMLHttpRequest.prototype.setRequestHeader = <span class="function"><span class="keyword">function</span> (<span class="params">header, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录 header</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.XMLHttpRequest.prototype.abort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>hook XHR 时要考虑的问题就是在 XHR 正在发送请求的时候，需不需要暂停我们的其他操作（如触发事件）？ 我们注入的代码的下一个操作可能会中断正在发送的 XHR 请求，导致更多链接的丢失，比较典型的例子就是：<a href="http://testphp.vulnweb.com/AJAX/index.php" target="_blank" rel="noopener">AJAX Demo</a>，这个问题没有标准答案。</p><p><code>WebSocket</code>、<code>EventSource</code>、<code>fetch</code> 和 XHR 差不多：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oldWebSocket = <span class="built_in">window</span>.WebSocket;</span><br><span class="line"><span class="built_in">window</span>.WebSocket = <span class="function"><span class="keyword">function</span>(<span class="params">url, arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> oldWebSocket(url, arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldEventSource = <span class="built_in">window</span>.EventSource;</span><br><span class="line"><span class="built_in">window</span>.EventSource = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> oldEventSource(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldFetch = <span class="built_in">window</span>.fetch;</span><br><span class="line"><span class="built_in">window</span>.fetch = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new link: "</span> + url);</span><br><span class="line">    <span class="keyword">return</span> oldFetch(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>我们还需要 hook 两个定时器函数：</p><ul><li><code>setTimeout</code></li><li><code>setInterval</code></li></ul><p>因为可能用户代码会延迟或者定期做一些操作，我们可能等不来那么长的时间，所以我们要给这些定时器做一个加速，也就是 Hook 之后修改相对应的 delay 为更小的值，同时加速之后也要 hook <code>Date</code> 类来同步时间。</p><h4 id="锁定"><a href="#锁定" class="headerlink" title="锁定"></a>锁定</h4><p>我们可以 hook 这些函数，那么其他人也可以继续 hook 这些函数，但一般对这些函数进行 hook 的人都不是什么好人，被别人继续 hook 之后可能会影响到我们的代码，所以我们还需要锁定这些基础函数。</p><p>例子：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.open = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'hook before defineProperty'</span>); &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'open'</span>, &#123;</span><br><span class="line">    value: <span class="built_in">window</span>.open,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.open = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'hook after defineProperty'</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.open(<span class="string">'http://www.fatezero.org'</span>)</span><br></pre></td></tr></table></figure></p><p>结果：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hook before defineProperty</span><br></pre></td></tr></table></figure></p><p>第一阶段我们能做的事情也做得差不多了，剩下的事情就交给第二阶段的代码干了。</p><h2 id="0x03-遍历节点"><a href="#0x03-遍历节点" class="headerlink" title="0x03 遍历节点"></a>0x03 遍历节点</h2><p>第二阶段，也就是页面稳定后，我们肯定是要先遍历 DOM 中的各个节点，然后才能获取节点上的链接信息，以及触发节点上绑定的事件，所以这里我们看一下获取 DOM 中所有的节点，有哪些方法：</p><ul><li>CDP 的 <code>DOM.querySelectorAll</code></li><li>document.all</li><li>document.querySelectorAll</li><li>TreeWalker</li></ul><p>我们一个一个的排除，首先排除 CDP，因为如果使用 CDP 遍历各个节点，那就意味着后续的对节点的操作也要继续使用 CDP 才能进行，其速度远没有在一个 Context 内的代码操作 DOM 快。接着排除 <code>document.all</code>(<code>HTMLAllCollection</code>，动态元素集合) 和 <code>document.querySelectorAll</code>(<code>NodeList</code>, 静态元素集合)，因为这两个都只是元素集合，而不是节点集合，并不包含 text, comment 节点。最后就剩下 TreeWalker 了。</p><p>TreeWalker 也有两种玩法，一种是先获取所有的节点，然后在触发各个节点上的事件，另外一种是边遍历节点，边触发事件。</p><p>可能会有同学觉得第二种方法比较优雅，我们看一下使用第二种方法的一种情况：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"a1"</span>&gt;</span>hello a1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"a2"</span> <span class="attr">onclick</span>=<span class="string">"removeA2()"</span>&gt;</span>hello a2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"a3"</span>&gt;</span>hello a3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">removeA2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span></span><br><span class="line"><span class="javascript">    c.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'a2'</span>));</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">treeWalkerFilter</span>(<span class="params">element</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (element.nodeType === Node.ELEMENT_NODE) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> NodeFilter.FILTER_ACCEPT;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">treeWalker = <span class="built_in">document</span>.createTreeWalker(</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>,</span></span><br><span class="line"><span class="undefined">    NodeFilter.SHOW_ELEMENT,</span></span><br><span class="line"><span class="undefined">    treeWalkerFilter,</span></span><br><span class="line"><span class="javascript">    <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">while</span> (treeWalker.nextNode()) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"[*] processing node "</span> + treeWalker.currentNode.tagName + <span class="string">' '</span> + treeWalker.currentNode.id);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (treeWalker.currentNode.click) &#123;</span></span><br><span class="line"><span class="undefined">        treeWalker.currentNode.click();</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(treeWalker.currentNode);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>结果：</p><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/treewalker.png" width="400"><p>是的，如果 TreeWalker 刚好走到一个节点，触发了事件使得该节点离开了 DOM 树，那 TreeWalker 就走不下去了，所以比较保险的方法就是在页面稳定后收集一份静态的节点列表，再触发事件，也就是使用 <code>TreeWalker</code> 的第一种玩法。</p><h2 id="0x04-事件触发"><a href="#0x04-事件触发" class="headerlink" title="0x04 事件触发"></a>0x04 事件触发</h2><p>在收集到一份静态节点列表，获取静态节点列表的链接信息之后，我们就该考虑一下如何触发各个节点上的事件了。</p><p>首先，我们来谈一下如何触发鼠标、键盘相关的事件，主要方法有两：</p><ul><li><code>dispatchEvent</code></li><li>CDP 的 <code>Input.dispatchMouseEvent</code></li></ul><p>我们使用一个简单的例子看一下两者最大的差别：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">onclick</span>=<span class="string">"testEventTrusted(event)"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">testEventTrusted</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="string">"isTrusted"</span> <span class="keyword">in</span> event) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (event.isTrusted) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"trusted"</span>);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"not trusted"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"not support"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 CDP 测试两者区别：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line"></span><br><span class="line">tab = browser.new_tab()</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line">tab.Page.navigate(url=<span class="string">"http://localhost/test.html"</span>)</span><br><span class="line"></span><br><span class="line">tab.Runtime.enable()</span><br><span class="line">tab.Runtime.evaluate(expression=<span class="string">"console.log('js click: ')"</span>)</span><br><span class="line">tab.Runtime.evaluate(expression=<span class="string">"var e = new MouseEvent('click');test.dispatchEvent(e);"</span>, _timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">result = tab.Runtime.evaluate(expression=<span class="string">'test'</span>, _timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">btn_object_id = result[<span class="string">'result'</span>][<span class="string">'objectId'</span>]</span><br><span class="line">result = tab.DOM.getBoxModel(objectId=btn_object_id)</span><br><span class="line"></span><br><span class="line">border = result[<span class="string">'model'</span>][<span class="string">'border'</span>]</span><br><span class="line"></span><br><span class="line">odd = [value <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(border) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>]</span><br><span class="line">even = [value <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(border) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">x = min(even)</span><br><span class="line">y = min(odd)</span><br><span class="line">width = max(even) - x</span><br><span class="line">height = max(odd) - y</span><br><span class="line"></span><br><span class="line">x += width / <span class="number">2</span></span><br><span class="line">y += height / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">tab.Runtime.evaluate(expression=<span class="string">"console.log('cdp click: ')"</span>)</span><br><span class="line">tab.Input.dispatchMouseEvent(type=<span class="string">"mousePressed"</span>, x=x, y=y, button=<span class="string">'left'</span>, clickCount=<span class="number">1</span>)</span><br><span class="line">tab.Input.dispatchMouseEvent(type=<span class="string">"mouseReleased"</span>, x=x, y=y, button=<span class="string">'left'</span>, clickCount=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/event_js_and_cdp_result.png" width="280"><p><code>dispatchEvent</code> 和 <code>Input.dispatchMouseEvent</code> 这两者最大的区别就是事件来源是否是真实的用户点击，虽说 <code>isTrusted</code> 也就是一个改 Chromium 代码就能解决的问题，但我们也没法保证还有没有其他黑科技来检测是否事件是否来自真实用户。然而我还是觉得 CDP 实在太慢，所以还是继续选择使用 <code>dispatchEvent</code> 来触发各种事件。</p><p>接下来我们要考虑一下如何使用 <code>dispatchEvent</code> 触发事件，可能有些同学觉得，我们可以扫描所有元素节点，收集内联事件，对于动态添加的事件，可以 Hook <code>addEventListener</code> 获取到，最后再挨个触发元素相对应的事件，其实这样做是有问题的。</p><p>我们还是先看看一个例子：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">onclick</span>=<span class="string">"btnClick(event)"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span>&gt;</span>click1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn2"</span>&gt;</span>click2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">btnClick</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'click: '</span> + e.target.id);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>例子将事件绑定在 container 内，等事件冒泡到 container，再通过 event.target 区分元素。如果按照之前的思路，我们的代码将会在 container 中触发一个点击事件，而忽略了 container 下的两个按钮，所以之前的思路并不合理。</p><p>我个人的想法是，每个元素都只触发常用的事件，比如说 <code>click</code>、<code>dbclick</code>、<code>mouseover</code> 等事件，忽略一些非主流事件。只触发常见的键盘、鼠标事件让我们的行为更像是一个正常人类的行为，这样也减少了被反爬虫机制带入坑的可能性。另外，说到爬虫行为做到和正常人类类似，还有一个小细节，那就是元素是否在可见区域，以前都是直接将浏览器的 viewpoint 设置最大，现在我们使用 <code>element.scrollIntoViewIfNeeded</code> 将滚动条滚动到元素的位置，然后再触发事件。</p><h2 id="0x05-新节点"><a href="#0x05-新节点" class="headerlink" title="0x05 新节点"></a>0x05 新节点</h2><p>那么问题又来了，由于我们各种点击、敲击键盘、尝试触发各种操作而产生新的节点，我们该怎么办？肯定还是要继续处理这些新节点，但是怎么找到这些新节点，难道还要重新再扫一遍 DOM 查找新节点？有没有一个方法可以获取到变化的属性和节点？</p><p>在 HTML5 中就刚好有这么一个类 <code>MutationObserver</code>，我们看看例子：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">onclick</span>=<span class="string">"createE()"</span>&gt;</span>create element<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn2"</span> <span class="attr">onclick</span>=<span class="string">"changeA()"</span>&gt;</span>change attr<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form1"</span> <span class="attr">action</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    btn1.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> eA = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span></span><br><span class="line"><span class="javascript">        eA.href = <span class="string">"http://www.fatezero.org"</span>;</span></span><br><span class="line"><span class="undefined">        container.appendChild(eA);</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    btn2.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        form1.action = <span class="string">"http://www.fatezero.org/form"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations </span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        mutations.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">mutation</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (mutation.type === <span class="string">'childList'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 在创建新的 element 时调用</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"child list: "</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(mutation);</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutation.type === <span class="string">'attributes'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 在属性发生变化时调用</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"attributes: "</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(mutation);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    observer.observe(<span class="built_in">window</span>.document, &#123;</span></span><br><span class="line"><span class="javascript">        subtree: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        childList: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        attributes: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        attributeFilter: [<span class="string">'src'</span>, <span class="string">'href'</span>, <span class="string">'action'</span>]</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按顺序点击 btn1 和 btn2 的结果：</p><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/mutation_observer_result.png" width="600"><p>所以我们完全可以利用 <code>MutationObserver</code> 作深度优先的扫描，如果弹出新的节点，那就优先处理新的节点。每次都是先静态扫描新的节点列表，然后再尝试触发新增节点列表的事件。</p><p>但是值得注意的是 <code>MutationObserver</code> 并不会实时将变更元素传回来，而是收集一个时间段的元素再传回来，所以未能及时切换到新的节点继续触发事件也是正常的事情。</p><h2 id="0x06-自动填写表单"><a href="#0x06-自动填写表单" class="headerlink" title="0x06 自动填写表单"></a>0x06 自动填写表单</h2><p>OK，事件我们触发了，新节点我们也处理了，这里我们还需要对一些元素进行特殊处理，比如说自动填写表单内的输入元素。</p><p>这一小节没什么难度，主要是判定哪些地方该填名字，哪些地方该填邮箱，哪些地方该填号码，需要根据不同情况输入对应的数据。另外还要注意的是在填写数据的时候还要触发对应的事件，例如填写 <code>&lt;input type=&quot;text&quot;&gt;</code> 的时候，我们需要把鼠标移动到 <code>input</code> 元素上，对应触发 <code>mouseover</code>、<code>mouseenter</code>、<code>mousemove</code> 消息，接着要鼠标点击一下输入点，对应 <code>mousedown</code>、<code>mouseup</code>、<code>click</code> 消息，然后鼠标移开转到其他元素去，对应 <code>mousemove</code>、<code>mouseout</code>、<code>mouseleave</code> 消息。</p><p>这里还有个小建议，所有的用户输入都带上一个可识别的词，例如我们自定义词为 CasterJS，email 处就填写 <code>casterjs @gmail.com</code>， addr 处就写 <code>casterjs road</code>， 至于为什么下一篇再说。 </p><h2 id="0x07-CDP"><a href="#0x07-CDP" class="headerlink" title="0x07 CDP"></a>0x07 CDP</h2><p>这一个小结主要和 CDP 相关的 TIP ，使用什么语言操控 CDP 都行，在这里我选择我比较熟悉的 Python 作为解释。</p><h4 id="自定义-request"><a href="#自定义-request" class="headerlink" title="自定义 request"></a>自定义 request</h4><p>CDP 在 navigate 的时候并不能直接自定义 request，通俗的讲就是在 navigate 的时候并不能设置 method 和 headers 等信息，但很明显这个功能对我们的扫描器来说非常重要。幸运的是，虽然 CDP 没有直接支持这样的功能，但可以通过 <code>Network.requestIntercepted</code> 变向实现这样的功能。</p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_intercepted</span><span class="params">(interceptionId, request, **kwargs)</span>:</span></span><br><span class="line">    headers = request.get(<span class="string">'headers'</span>, &#123;&#125;)</span><br><span class="line">    headers[<span class="string">'Test-key'</span>] = <span class="string">'test-value'</span></span><br><span class="line"></span><br><span class="line">    tab.Network.continueInterceptedRequest(</span><br><span class="line">        interceptionId=interceptionId,</span><br><span class="line">        headers=headers,</span><br><span class="line">        method=<span class="string">'POST'</span>,</span><br><span class="line">        postData=<span class="string">"hello post data: %s"</span> % time.time()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line">tab = browser.new_tab()</span><br><span class="line"></span><br><span class="line">tab.Network.requestIntercepted = request_intercepted</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    tab.Network.setRequestInterception(patterns=[&#123;<span class="string">'urlPattern'</span>: <span class="string">'*'</span>, <span class="string">'resourceType'</span>: <span class="string">'Document'</span>&#125;])</span><br><span class="line"><span class="keyword">except</span> pychrome.exceptions.CallMethodException:</span><br><span class="line">    tab.Network.setRequestInterceptionEnabled(enabled=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">tab.Page.navigate(url=<span class="string">"http://httpbin.org/post"</span>)</span><br><span class="line"></span><br><span class="line">tab.wait(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">result = tab.Runtime.evaluate(expression=<span class="string">"document.documentElement.outerText"</span>)</span><br><span class="line">html_content = result.get(<span class="string">'result'</span>, &#123;&#125;).get(<span class="string">'value'</span>, <span class="string">""</span>)</span><br><span class="line">print(html_content)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"data"</span>: <span class="string">"hello post data: 1521343371.056448"</span>, </span><br><span class="line">  <span class="attr">"files"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"form"</span>: &#123;&#125;, </span><br><span class="line">  <span class="attr">"headers"</span>: &#123;</span><br><span class="line">    <span class="attr">"Accept"</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span>, </span><br><span class="line">    <span class="attr">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, </span><br><span class="line">    <span class="attr">"Connection"</span>: <span class="string">"close"</span>, </span><br><span class="line">    <span class="attr">"Content-Length"</span>: <span class="string">"34"</span>, </span><br><span class="line">    <span class="attr">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="attr">"Test-Key"</span>: <span class="string">"test-value"</span>, </span><br><span class="line">    <span class="attr">"Upgrade-Insecure-Requests"</span>: <span class="string">"1"</span>, </span><br><span class="line">    <span class="attr">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/63.0.3239.150 Safari/537.36"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"json"</span>: <span class="literal">null</span>, </span><br><span class="line">  <span class="attr">"origin"</span>: <span class="string">"1.1.1.1"</span>, </span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h4><p>我们的浏览器是肯定需要加载 css 和 js 的，那其他网络资源如图片、视频等媒体资源是不是可以直接禁止加载？其实这样做并不合理，直接禁用图片等资源可能会影响到用户代码执行逻辑，例如我们常见的 <code>&lt;img src=1 onerror=alert(1)&gt;</code>，所以比较好的解决方法就是返回假的媒体资源。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"><span class="keyword">import</span> pychrome.exceptions</span><br><span class="line"></span><br><span class="line">image_raw_response = (<span class="string">'SFRUUC8xLjEgMjAwIE9LCkNvbnRlbnQtVHlwZTogaW1hZ2UvcG5nCgqJUE5HDQoaCgAAAA1JSERSAAAAAQ'</span></span><br><span class="line">                      <span class="string">'AAAAEBAwAAACXbVsoAAAAGUExURczMzP///9ONFXYAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAKSURBVAiZY'</span></span><br><span class="line">                      <span class="string">'2AAAAACAAH0cWSmAAAAAElFTkSuQmCC'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requestIntercepted</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> image_raw_response</span><br><span class="line">    resource_type = kwargs.get(<span class="string">'resourceType'</span>, <span class="string">'other'</span>).lower()</span><br><span class="line">    interception_id = kwargs.get(<span class="string">'interceptionId'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resource_type == <span class="string">'image'</span>:</span><br><span class="line">        tab.Network.continueInterceptedRequest(</span><br><span class="line">            interceptionId=interception_id,</span><br><span class="line">            rawResponse=image_raw_response,</span><br><span class="line">            _timeout=<span class="number">5</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tab.Network.continueInterceptedRequest(</span><br><span class="line">            interceptionId=interception_id,</span><br><span class="line">            _timeout=<span class="number">5</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line">tab = browser.new_tab()</span><br><span class="line"></span><br><span class="line">tab.Network.requestIntercepted = requestIntercepted</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line">tab.Page.enable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    tab.Network.setRequestInterception(patterns=[&#123;<span class="string">'urlPattern'</span>: <span class="string">'*'</span>, <span class="string">'resourceType'</span>: <span class="string">'Image'</span>&#125;])</span><br><span class="line"><span class="keyword">except</span> pychrome.exceptions.CallMethodException:</span><br><span class="line">    tab.Network.setRequestInterceptionEnabled(enabled=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">tab.Page.navigate(url=<span class="string">"https://weibo.com/fatez3r0"</span>)</span><br><span class="line">tab.wait(<span class="number">60</span>)</span><br></pre></td></tr></table></figure><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-02/replace_images.png" width="700"><h4 id="session-isolate"><a href="#session-isolate" class="headerlink" title="session isolate"></a>session isolate</h4><p>我们的扫描器可能会有使用不同用户信息扫描同一个域名的情况，我们肯定不希望在同一个 browser 下，不同 tab 的 Cookie 信息等串在一起，我们希望每个 tab 都有一个隐身模式，每个 tab 都资源互不影响，比较走运的是 Headless Chrome 刚好有这么一个功能，叫 session isolate ，也是 Headless 模式下独有的功能。</p><p>我们看一下 Headless 模式的 session isolate 功能的简单例子:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line"></span><br><span class="line">browser = pychrome.Browser()</span><br><span class="line">version_info = browser.version()</span><br><span class="line"></span><br><span class="line">target = pychrome.Tab(webSocketDebuggerUrl=version_info[<span class="string">'webSocketDebuggerUrl'</span>], id=<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">target.start()</span><br><span class="line">tab0 = browser.new_tab(url=<span class="string">"http://httpbin.org/cookies/set?browser=here_is_fate0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 尝试注释下面这行</span></span><br><span class="line">browser_context_id1 = target.Target.createBrowserContext()[<span class="string">'browserContextId'</span>]</span><br><span class="line">target_id1 = target.Target.createTarget(</span><br><span class="line">    url=<span class="string">"http://httpbin.org/cookies"</span>,</span><br><span class="line">    <span class="comment"># 2. 以及这行</span></span><br><span class="line">    browserContextId=browser_context_id1</span><br><span class="line">)[<span class="string">'targetId'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab1 = pychrome.Tab(</span><br><span class="line">    id=target_id1,</span><br><span class="line">    webSocketDebuggerUrl=<span class="string">'ws://127.0.0.1:9222/devtools/page/&#123;&#125;'</span>.format(target_id1)</span><br><span class="line">)</span><br><span class="line">tab1.start()</span><br><span class="line">tab1.Runtime.enable()</span><br><span class="line">print(tab1.Runtime.evaluate(expression=<span class="string">'document.documentElement.outerText'</span>))</span><br></pre></td></tr></table></figure><p>运行结果：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'result'</span>: &#123;<span class="string">'type'</span>: <span class="string">'string'</span>, <span class="string">'value'</span>: <span class="string">'&#123;\n  "cookies": &#123;&#125;\n&#125;\n'</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>如果注释 1、2 两行，运行结果：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'result'</span>: &#123;<span class="string">'type'</span>: <span class="string">'string'</span>, <span class="string">'value'</span>: <span class="string">'&#123;\n  "cookies": &#123;\n    "browser": "here_is_fate0"\n  &#125;\n&#125;\n'</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>所以只要每个 tab 都新建一个 <code>BrowserContext</code> 就可以做到互不干扰了，这也就相当于每个 tab 都是一个独立的隐身模式，能够做到每个 tab 互不影响，也可以共用一个 <code>BrowserContext</code> 达到共享 cache、cookie 之类信息的功能。</p><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>从 chromium 62 开始存在一个安全问题，在使用 <code>remote-debugging-port</code> 参数的时候可以系统上任意写文件，我已经提交安全 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=824816" target="_blank" rel="noopener">issue</a> 给 chromium，可惜撞洞了，有人比我早了一个月提交了<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=813540" target="_blank" rel="noopener">相关漏洞</a>，所以在选定 chromium 版本的时候要注意跳过这些版本或者自行修复这些问题。</p><h2 id="0x08-结合"><a href="#0x08-结合" class="headerlink" title="0x08 结合"></a>0x08 结合</h2><p>讲了那么多，是时候该把所有的东西结合在一起，我们先简单捋一下执行过程：</p><ol><li>注入 Hook 相关的 JavaScript 代码</li><li>使用 TreeWalker 遍历节点，收集节点链接信息，获取静态的节点列表</li><li>触发各个节点的相关操作，自动填写表单</li><li>MutationObserver 监控动态节点创建，优先处理新节点</li></ol><p>我们以 <code>http://testphp.vulnweb.com/AJAX/index.php</code> 作为例子跑一遍，看一下我们代码的执行状况，为了更方便的展示，我将每个节点（触发事件）的处理时间都额外增加了 0.1s，同时也给所有节点都加上了边框，蓝色边框表示正在处理的节点。</p><p>测试视频如下：</p><video src="http://static.fatezero.org/blog/video/web-scanner-crawler-02/vulnweb_test.mov" type="video/mov" controls="controls" width="100%" height="100%"></video><p>通过加边框和打 log 的方式，我们完全可以一步一步的看着爬虫的操作是否符合我们的预期。这个例子的结果证明了:</p><ul><li>xhr 的 hook（不被其他 xhr 中断）</li><li>事件的触发（新节点的产生）</li><li><code>MutationObserver</code> 的监控（正确处理新节点）</li><li>图片资源的处理（原始图片被替换）</li><li>窗口的处理（没有弹 alert 窗）</li></ul><p>上面的行为是符合我们的预期的。</p><p>目前第一篇和第二篇的内容总算是组合在了一起，成为了一个能够独立运行、测试的组件，该组件所提供的功能就是输入一个 request 相关的信息，返回 response 中所有的链接信息，如果我们的爬虫存在链接信息漏抓，那很可能就是这部分出问题，所以也只需要调试这部分代码即可，非常方便。</p><p>该组件可以通过stdin/stdout、RPC、消息队列等方式传递任务和结果。可以通过在单台机器上多开 tab 达到纵向扩展，也可以在多台机器上启多个 browser 达到横向扩展，这部分各自有自个的想法，不会就这个方向继续写下去了。</p><h2 id="0x09-总结"><a href="#0x09-总结" class="headerlink" title="0x09 总结"></a>0x09 总结</h2><p>至此，Web 漏洞扫描器爬虫中的 <code>Downloader</code> 这部分我已经简单地介绍了一遍，对照一下我自己的代码，也深知这部分我并没有讲全，因为这部分坑多，内容也乱且多，但是再写下去就真的没完没了，看着累，写着更累，得赶紧切到下一个话题。</p><p><a href="#">下一篇</a>，我将会继续介绍爬虫的调度部分以及整体架构。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://blog.fatezero.org/2018/03/05/web-scanner-crawler-01/&quot;&gt;上一篇&lt;/a&gt;主要讲了如何通过修改 Chromium 代码为 Web 漏洞扫描器的爬虫打造一个稳定可靠的 headless 浏览器。这一篇我们从浏览器底层走到上层，从 C++ 切换到 JavaScript，讲一下如何通过向浏览器页面注入 JavaScript 代码来尽可能地获取页面上的链接信息。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>爬虫基础篇[Web 漏洞扫描器]</title>
    <link href="http://blog.fatezero.org/2018/03/05/web-scanner-crawler-01/"/>
    <id>http://blog.fatezero.org/2018/03/05/web-scanner-crawler-01/</id>
    <published>2018-03-05T00:00:24.000Z</published>
    <updated>2018-11-13T03:28:47.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>Web 漏扫的爬虫和其他的网络爬虫的技术挑战不太一样，漏扫的爬虫不仅仅需要爬取网页内容、分析链接信息，还需要尽可能多的触发网页上的各种事件，以便获取更多的有效链接信息。总而言之，Web 漏扫的爬虫需要不择手段的获取尽可能多新的链接信息。</p><a id="more"></a><p>在这篇博客文章中，我打算简单地介绍下和爬虫浏览器相关内容，爬虫基础篇倒不是说内容基础，而是这部分内容在漏扫爬虫中的地位是基础的。</p><h2 id="0x01-QtWebkit-or-Headless-Chrome"><a href="#0x01-QtWebkit-or-Headless-Chrome" class="headerlink" title="0x01 QtWebkit or Headless Chrome"></a>0x01 QtWebkit or Headless Chrome</h2><blockquote><p>QtWebkit or Headless Chrome, that is a question</p></blockquote><p>QtWebkit 还是 Headless Chrome，我们一个一个分析。</p><h4 id="QtWebkit"><a href="#QtWebkit" class="headerlink" title="QtWebkit"></a>QtWebkit</h4><p>我们先说一下在漏扫爬虫和 QtWebkit 相关的技术:</p><ul><li>使用 QtWebkit</li><li>使用 PhantomJS (基于 Qt 编写)</li><li>使用 PyQt (一个 Python 的 Qt bindings)</li></ul><p>这也是我之前在 TangScan 调研 QtWebkit 系列的时候面对的技术，当时就首先就排除了 PyQt，因为在 PyQt 中没有办法自定义 <a href="http://doc.qt.io/qt-5/qpa.html" target="_blank" rel="noopener">QPA</a> 插件，如果不借用 xvfb，是没法在没有 X Server 的服务器上跑起来的，本来 PyQt 已经够慢，再加上一个 xvfb，那就更慢了，所以直接排除 PyQt。</p><p>接着讨论 PhantomJS，PhantomJS 的优点是简单，不需要再次开发，直接使用 js 就可以操作一个浏览器，所以 TangScan 内部的第一个版本也选择了 PhantomJS，但后面也发现了 PhantomJS 的不足。</p><p>首先 PhantomJS 可以使用 js 操作浏览器是个优点，但也必须多出一个 js context (QWebPage) 开销，而且有时候 js 的 callback 在一些情况下没有被调用。其次我所需要的功能 PhantomJS 并没有提供，然而在 QtWebkit 中可以实现。</p><p>所以 TangScan 内部的第二版，我选择了使用 QtWebkit 来重新写一个类似 PhantomJS 的东西 (内部名为 CasterJS，AWVS 也是用 QtWebkit 写了个名为 marvin 的爬虫)。</p><p>但是直接使用 QtWebkit 还是有问题。首先自从 Qt5.2 之后，对应的 WebKit 引擎就没有再更新过，别说支持 ES6 了，函数连 <code>bind</code> 方法都没有。其次内存泄漏问题严重，最明显的情况就是设置默认不加载图片 <code>QWebSettings::AutoLoadImages</code> 的时候，内存使用率蹭蹭地往上涨。最后也是最严重的问题，稳定性欠缺，也是自己实现了 CasterJS 之后才知道为什么 PhantomJS 上为什么会有那么多没处理的 issue，这个不稳定的原因是第三方库不稳定 (老旧的 Webkit)，自己还不能更换这个第三方库。当时在 TangScan 的时候，就非常头疼这些明知道不是自己的锅、解决起来特麻烦、还必须得解决的问题。</p><p>所以如果没有其他选择，QtWebkit 忍一忍还是能继续使用下去，但是 Headless Chrome 出现了。</p><h4 id="Headless-Chrome"><a href="#Headless-Chrome" class="headerlink" title="Headless Chrome"></a>Headless Chrome</h4><p>Chrome 的 Headless 模式在 2015-08 开始低调开发，2016-06 开始对外公开，2017-04 在 M59 上正式发布。</p><p>后来 PhantomJS 的开发者 Vitaly Slobodin 在 PhantomJS 邮件组发出了公告 <a href="https://groups.google.com/forum/#!topic/phantomjs/9aI5d-LDuNE" target="_blank" rel="noopener">[Announcement] Stepping down as maintainer</a>，听到这个消息我真的一点都不意外，在 TangScan 中，也是使用 Qt 从头开发起 CasterJS 的我来说，已经受够了由于老旧的 Webkit 版本带来的各种 crash，内存泄漏，QtWebkit 这个坑实在是太坑了。</p><p>Vitaly Slobodin 在当时作为 PhantomJS 唯一的主要开发者，面对着 PhantomJS 项目上那接近 2k 的 issue，心有余而力不足，而且 crash 问题占多数。虽然说很多问题上游的 Webkit 已经解决了，但偏偏 Qt 一直绑定的都是 Webkit 几年前的版本，所以 Vitaly Slobodin 就真的自个单独维护一个 QtWebkit 仓库，用于专门解决这样的问题。但是作为 PhantomJS 唯一的开发者，既要开发新功能，又要持续跟进 QtWebkit 各种 BUG，力不从心。然后雪上加霜的是 Qt 在 Qt 5.2 的时候宣布打算放弃 QtWebkit，不在进行更新，转而使用基于 Chromium 的 QWebEngine 取代 QtWebkit。虽然后来 <a href="https://github.com/annulen/webkit/releases" target="_blank" rel="noopener">annulen</a> 扛起了大旗，说要继续维护 QtWebkit，要从 Webkit 那里一点一点地更新代码，但个人开发速度还是比不上一个团队。这个时候 Headless Chrome 出来了，Vitaly Slobodin 在这个时候退出 PhantomJS 的开发是最好的选择了。</p><p>Headless Chrome 的出现也让我哭笑不得，哭的原因是因为 Headless Chrome 让我在 TangScan 开发的 CasterJS 变得毫无意义，笑的原因因为 Headless Chrome 比其他基于 QtWebkit 写的 Headless 浏览器更快速、稳定、简单，让我跳出了 QtWebkit 这个坑。</p><p>夸了那么久 Headless Chrome 不过也并不代表 Headless Chrome 毫无缺点，首先 Chrome 的 Headless 模式算是一个比较新的特性，一些功能还不算完善，只能等官方实现或者自行实现(比方说 interception 这个功能我就等了几个月)。其次 CDP 所提供的 API 不稳定，还会存在变动(比方说 M63 和 M64 中 <code>Network.continueInterceptedRequest</code> 的变动)，所以在使用 Headless Chrome 的时候，一定要先确定的 Chrome 版本，再编写和 CDP 相关的代码。</p><p>当然我也发现有些公司内部扫描器在使用 IE，大致过了一遍代码，我个人并不觉得这是个好方案，所以我还是坚持使用 Headless Chrome。</p><h2 id="0x02-小改-Chromium"><a href="#0x02-小改-Chromium" class="headerlink" title="0x02 小改 Chromium"></a>0x02 小改 Chromium</h2><p>OK，既然我们已经选定了 Headless Chrome，是不是可以撸起袖子开始干了呢，很抱歉，目前 Headless Chrome 还是不太满足我们扫描器爬虫的需求，我们还需要对其代码进行修改。</p><p>官方文档很详细的介绍了如何编译、调试 Chromium，只要网络没问题(需翻墙)，一般也不会遇到什么大问题，所以这里也没必要介绍相关知识。</p><h4 id="hook-location"><a href="#hook-location" class="headerlink" title="hook location"></a>hook location</h4><p>我们先看一下这个例子</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">window.location = '/test1';</span></span><br><span class="line"><span class="undefined">window.location = '/test2';</span></span><br><span class="line"><span class="undefined">window.location = '/test3';</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个场景面临的问题和 <a href="https://github.com/bedirhan/wivet/blob/master/pages/9.php" target="_blank" rel="noopener">wivet - 9.php</a> 有点儿类似: 怎么样把所有跳转链接给抓取下来?</p><p>可能熟悉 QtWebkit 的同学觉得直接实现 <code>QWebPage::acceptNavigationRequest</code> 虚函数就可以拦截所有尝试跳转的请求.</p><p>可能熟悉 Headless Chrome 的同学会说在 CDP 中也有 <code>Network.continueInterceptedRequest</code> 可以拦截所有网络请求，当然也包括跳转的请求。</p><p>但实际上这两种方法都只能获取到最后一个 <code>/test3</code> 链接，因为前面两次跳转都很及时的被下一次跳转给中断了，所以更不会尝试发出跳转请求，类似 intercept request 的 callback 就不可能获取到所有跳转的链接。</p><p>要是 location 能够使用 <code>defineProperty</code> 进行修改，那问题就简单多了。但是在一般的浏览器中 location 都是 unforgeable 的，也就是不能使用 <code>defineProperty</code> 进行修改，不过现在 Chromium 代码在我们手上，所以完全可以将其修改为可修改的，直接修改 location 对应的 idl 文件即可:</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/third_party/WebKit/Source/core/frame/Window.idl</span></span><br><span class="line"><span class="comment">+++ b/third_party/WebKit/Source/core/frame/Window.idl</span></span><br><span class="line"><span class="meta">@@ -39,7 +39,7 @@</span></span><br><span class="line">     [Unforgeable, CachedAccessor] readonly attribute Document document;</span><br><span class="line">     [Replaceable] readonly attribute DOMString origin;</span><br><span class="line">     attribute DOMString name;</span><br><span class="line"><span class="deletion">-    [PutForwards=href, Unforgeable, CrossOrigin=(Getter,Setter), Custom=Getter] readonly attribute Location location;</span></span><br><span class="line"><span class="addition">+    [PutForwards=href, CrossOrigin=(Getter,Setter), Custom=Getter] readonly attribute Location location;</span></span><br><span class="line">     readonly attribute History history;</span><br><span class="line">     [Replaceable, MeasureAs=BarPropLocationbar] readonly attribute BarProp locationbar;</span><br><span class="line">     [Replaceable, MeasureAs=BarPropMenubar] readonly attribute BarProp menubar;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/third_party/WebKit/Source/core/dom/Document.idl</span></span><br><span class="line"><span class="comment">+++ b/third_party/WebKit/Source/core/dom/Document.idl</span></span><br><span class="line">@@ -92,7 +92,7 @@ typedef (HTMLScriptElement or SVGScriptElement) HTMLOrSVGScriptElement;</span><br><span class="line"> </span><br><span class="line">     // resource metadata management</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-    [PutForwards=href, Unforgeable] readonly attribute Location? location;</span></span><br><span class="line"><span class="addition">+    [PutForwards=href] readonly attribute Location? location;</span></span><br><span class="line">     [RaisesException=Setter] attribute DOMString domain;</span><br><span class="line">     readonly attribute DOMString referrer;</span><br><span class="line">     [RaisesException, RuntimeCallStatsCounter=DocumentCookie] attribute DOMString cookie;</span><br></pre></td></tr></table></figure><p>测试代码:<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">Object.defineProperty(window, "location", &#123;</span></span><br><span class="line"><span class="undefined">    set: function (newValue) &#123;</span></span><br><span class="line"><span class="undefined">        console.log("new value: " + newValue);</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    get: function () &#123;</span></span><br><span class="line"><span class="undefined">        console.log("get value");</span></span><br><span class="line"><span class="undefined">        return 123;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">console.log(document.location);</span></span><br><span class="line"><span class="undefined">console.log(window.location);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>修改前:</p><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-01/locaiton_error.png" width="500"><p>修改后:</p><img src="http://static.fatezero.org/blog/img/web-scanner-crawler-01/location_unforgeable.png" width="500"><p>我之所以觉得伪造 location 这个特性很重要，是因为不仅仅在爬虫中需要到这个特性，在实现 DOM XSS 检测的时候这个特性也非常重要，虽然说 Headless Chrome 官方文档上有提过将来可能会让用户可以自由 hook location 的特性 (官方文档上也是考虑到 DOM XSS 这块)，但过了将近一年的时间，也没有和这个特性的相关消息，所以还是自己动手丰衣足食。</p><h4 id="popups-窗口"><a href="#popups-窗口" class="headerlink" title="popups 窗口"></a>popups 窗口</h4><p>我们再来看看这个例子</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.qq.com"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">name</span>=<span class="string">"popup"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    document.getElementsByName("popup")[0].submit();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Headless Chrome 中会直接弹出一个 popups 窗口，CDP 只能禁止当前 page 跳转，但是没办法禁止新 page 创建，在 QtWebkit 中并没有这样的烦恼，因为所有的跳转请求都由 <code>QWebPage::acceptNavigationRequest</code> 决定去留。</p><p>这个问题是 DM 同学提出来的，当时他和我讨论该问题。其实当时我也没有解决方法，于是我跑去 Headless Chrome 邮件组问了开发人员 <a href="https://groups.google.com/a/chromium.org/forum/#!topic/headless-dev/gmZU6xBv3Jk" target="_blank" rel="noopener">Is there any way to block popups in headless mode?</a>，开发人员建议我先监听 <code>Page.windowOpen</code> 或 <code>Target.targetCreated</code> 事件，然后再使用 <code>Target.closeTarget</code> 关闭新建的 popups 窗口。</p><p>那么问题就来了，首先如果等待 page 新建之后再去关闭，不仅仅浪费资源去新建一个无意义的 page，而且 page 对应的网络请求已经发送出去了，如果该网络请求是一个用户退出的请求，那么事情就更严重了。其次开发人员推荐的方法是没法区分新建的 page 是在某个 page 下新建的，还是通过 CDP 新建的。所以 Headless Chrome 开发人员的建议我并不是特别满意。</p><p>得，最好的办法还是继续修改代码，使其在 page 中无法新建 page：</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/third_party/WebKit/Source/core/page/CreateWindow.cpp</span></span><br><span class="line"><span class="comment">+++ b/third_party/WebKit/Source/core/page/CreateWindow.cpp</span></span><br><span class="line">@@ -282,6 +282,9 @@ static Frame* CreateNewWindow(LocalFrame&amp; opener_frame,</span><br><span class="line">                               const WebWindowFeatures&amp; features,</span><br><span class="line">                               NavigationPolicy policy,</span><br><span class="line">                               bool&amp; created) &#123;</span><br><span class="line"><span class="addition">+  // add by fate0</span></span><br><span class="line"><span class="addition">+  return nullptr;</span></span><br><span class="line"><span class="addition">+  </span></span><br><span class="line">   Page* old_page = opener_frame.GetPage();</span><br><span class="line">   if (!old_page)</span><br><span class="line">     return nullptr;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/third_party/WebKit/Source/core/page/CreateWindow.cpp</span></span><br><span class="line"><span class="comment">+++ b/third_party/WebKit/Source/core/page/CreateWindow.cpp</span></span><br><span class="line">@@ -396,6 +396,10 @@ DOMWindow* CreateWindow(const String&amp; url_string,</span><br><span class="line">                         LocalFrame&amp; first_frame,</span><br><span class="line">                         LocalFrame&amp; opener_frame,</span><br><span class="line">                         ExceptionState&amp; exception_state) &#123;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  // add by fate0</span></span><br><span class="line"><span class="addition">+  return nullptr;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   LocalFrame* active_frame = calling_window.GetFrame();</span><br><span class="line">   DCHECK(active_frame);</span><br></pre></td></tr></table></figure><h4 id="忽略-SSL-证书错误"><a href="#忽略-SSL-证书错误" class="headerlink" title="忽略 SSL 证书错误"></a>忽略 SSL 证书错误</h4><p>在 Headless Chrome 对外公开之后很长一段时间内，是没法通过 devtools 控制忽略 SSL 证书错误的，也没办法去拦截 Chrome 的各种网络请求。</p><p>直到<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=659662" target="_blank" rel="noopener">2017-03</a> 才实现了在 devtools 上控制忽略 SSL 证书错误的功能。</p><p>直到<a href="https://groups.google.com/a/chromium.org/forum/#!topic/headless-dev/uvms04dXTIM" target="_blank" rel="noopener">2017-06</a> 才实现了在 devtools 可以拦截并修改 Chrome 网络请求的功能。</p><p>这两个特性对于扫描器爬虫来说非常重要，尤其是拦截网络请求的功能，可偏偏这两功能结合在一起使用的时候，就会出现 BUG，在 puppeteer 上也有人提了 <a href="https://github.com/GoogleChrome/puppeteer/issues/1159" target="_blank" rel="noopener">ignoreHTTPSErrors is not working when request interception is on</a>，直至现在(2018-03-05)，Google 也并没有修复该 BUG，我还能说啥呢，还是自己动手，丰衣足食。</p><p>最简单的方法就是修改 Chromium 代码直接忽略所有的网站的 SSL 证书错误，这样也省了一个 CDP 的 callback，修改如下:</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- a/net/http/http_network_session.cc</span></span><br><span class="line"><span class="comment">+++ b/net/http/http_network_session.cc</span></span><br><span class="line">@@ -97,7 +97,7 @@ SettingsMap AddDefaultHttp2Settings(SettingsMap http2_settings) &#123;</span><br><span class="line"> </span><br><span class="line"> HttpNetworkSession::Params::Params()</span><br><span class="line">     : enable_server_push_cancellation(false),</span><br><span class="line"><span class="deletion">-      ignore_certificate_errors(false),</span></span><br><span class="line"><span class="addition">+      ignore_certificate_errors(true),</span></span><br><span class="line">       testing_fixed_http_port(0),</span><br><span class="line">       testing_fixed_https_port(0),</span><br><span class="line">       tcp_fast_open_mode(TcpFastOpenMode::DISABLED),</span><br></pre></td></tr></table></figure><p>测试环境 <a href="https://badssl.com" target="_blank" rel="noopener">badssl.com</a></p><p>在 Chromium 中还有一些其他可改可不改的地方，这里就不继续吐槽了。</p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>OK，折腾了那么久，终于把一个类似 wget 的功能实现好了(笑，相对于我之前基于 QtWebkit 从头实现一个类似 PhantomJS 的 CasterJS 来说，目前使用 Headless Chrome 稳定、可靠、快速，简直是漏扫爬虫的不二选择。</p><p>这篇博客就简单讲了一下和漏扫爬虫相关的 Headless 浏览器的知识，接下来就到了漏扫爬虫中最为重要的一点，这一点也就决定了漏扫爬虫链接抓取效果是否会比其他扫描器好，能好多少，这都会在扫描器的下一篇文章中继续介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;Web 漏扫的爬虫和其他的网络爬虫的技术挑战不太一样，漏扫的爬虫不仅仅需要爬取网页内容、分析链接信息，
还需要尽可能多的触发网页上的各种事件，以便获取更多的有效链接信息。
总而言之，Web 漏扫的爬虫需要不择手段的获取尽可能多新的链接信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web 漏洞扫描器" scheme="http://blog.fatezero.org/tags/Web-%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Package 钓鱼</title>
    <link href="http://blog.fatezero.org/2017/06/01/package-fishing/"/>
    <id>http://blog.fatezero.org/2017/06/01/package-fishing/</id>
    <published>2017-06-01T20:47:24.000Z</published>
    <updated>2018-11-13T03:28:47.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前几天 <code>Samba</code> 公开了一个远程代码执行的漏洞，然后各种 POC 也随之出现，<code>exploit-db</code> 上也有这样一个 Python 版本的 <a href="https://www.exploit-db.com/exploits/42060/" target="_blank" rel="noopener">POC:  Samba 3.5.0 - Remote Code Execution</a>.</p><a id="more"></a><p>直接执行 POC，报错误信息：</p><img src="http://static.fatezero.org/blog/img/package-fishing/run-poc-at-the-first-time.png"><p>这种情况非常简单，直接 <code>pip install smb</code> 就行，但是：</p><img src="http://static.fatezero.org/blog/img/package-fishing/install-smb-package.png"><p>好吧，我们还是需要 Google 一下这个 <code>smb</code> 的 package 名字，最后发现原来是 <code>pysmb</code>：</p><img src="http://static.fatezero.org/blog/img/package-fishing/install-pysmb-and-run-poc.png"><p>最后 POC 终于跑了起来.</p><p>我们再回过头来看看整个流程，似乎并没有什么地方不对劲。</p><p>直接说问题所在吧，如果你在 <code>2017-05-24</code> 到 <code>2017-05-31</code> 这段时间内执行过 <code>pip install smb</code> 或者 <code>pip download smb</code>，那么恭喜你，你的名字可能出现在我的绵羊墙上。</p><h3 id="0x01-试水-2017-05-23-19-00"><a href="#0x01-试水-2017-05-23-19-00" class="headerlink" title="0x01 试水 (2017-05-23 19:00)"></a>0x01 试水 (2017-05-23 19:00)</h3><p>第一天，我在 PyPI 上投放了 4 个 evil package: <code>python-dev</code>、<code>mongodb</code>、<code>proxy</code>、<code>shadowsock</code> 测试一下不检查 package、随意安装 package 的人有多少。</p><p>其中所有的内容都是用 <code>cookiecutter</code> 根据模版 <a href="https://github.com/fate0/cookiecutter-evilpy-package/tree/cf812e1f44ca052b5e7055a8ff8cf5c4d81dcf98" target="_blank" rel="noopener">cookiecutter-evilpy-package</a> 生成。</p><p>每个 package 都会收集用户的</p><ul><li>username</li><li>hostname</li><li>ip</li><li>hostinfo</li></ul><p>我选择了 GitHub Issues + webtask.io 的方式，将安装 evil package 的用户信息通过 webtask.io 中转到 GitHub Issues 上对外公开。</p><p>所以我就在 Github 上注册了个小马甲 <a href="https://github.com/evilpackage" target="_blank" rel="noopener">evilpackage</a> 专门提交 Issue。</p><p>因为 webtask.io 获取客户端 ip 的时候，其实获取到的是 webtask.io 前面 nginx 的 ip 地址，并不是用户的 ip，所以就只能在代码里面获取客户端的外网 ip.使用 webtask.io 和 GitHub Issues 的主要原因是这两都是免费的。</p><h2 id="0x02-增加投放-package-2017-05-24-19-00"><a href="#0x02-增加投放-package-2017-05-24-19-00" class="headerlink" title="0x02 增加投放 package (2017-05-24 19:00)"></a>0x02 增加投放 package (2017-05-24 19:00)</h2><p>查看了一天的 Issues 数量，大概有 700+，效果非常不错，决定继续投放 evil package。与此同时，@<a href="http://weibo.com/u/1260091985" target="_blank" rel="noopener">ztz</a> 同学也加入了游戏，也在 RubyGems 上投放 Gems。</p><p>继续投放 evil package，就必须想一些比较好的名字，我主要使用下面两种方法:</p><ol><li><p>Google 搜索提示框<br>直接根据 Google 的搜索框提示:</p><img src="http://static.fatezero.org/blog/img/package-fishing/google-search-input-list.png"><p>便收集到了没有在 PyPI 上注册，而且比较流行的 Package 名字:</p><ul><li>caffe</li><li>ffmpeg</li><li>git</li><li>mkl</li><li>opencl</li><li>opencv</li><li>openssl</li><li>pygpu</li><li>tkinter</li><li>vtk</li><li>proxy</li></ul></li><li><p>想象力<br>依据平时写代码的经验总结出下面可能觉得会常用，但并没有在 PyPI 上注册的 Package 名字:</p><ul><li>ftp</li><li>smb</li><li>hbase</li><li>samba</li><li>rabbitmq</li><li>zookeeper</li><li>phantomjs</li><li>memcached</li><li>requirement.txt</li><li>requirements.txt</li></ul></li></ol><p>其中 <code>requirements.txt</code> 并没有注册成功，稍后再说。</p><h2 id="0x03-暂停服务-2017-05-25-23-00"><a href="#0x03-暂停服务-2017-05-25-23-00" class="headerlink" title="0x03 暂停服务 (2017-05-25 23:00)"></a>0x03 暂停服务 (2017-05-25 23:00)</h2><p>晚上回家的时候又统计了一下安装量，一天安装量达到了 2000+，效果已经很显著，不必再增加新的 package 了，但是到了晚上 23:00 的时候，我的 GitHub Issues 被恶意插入脏数据，所以只能暂停服务：</p><img src="http://static.fatezero.org/blog/img/package-fishing/insert-useless-data.png"><p>之所以只能暂停服务，那是因为 webtask.io 没法获取客户端 ip，我也没法 ban 掉对应的 ip，作出任何相对的处理，只能停服务。</p><p>话说到底谁才是攻击者。</p><h2 id="0x04-evilpackage-被封-2017-05-26-2-00"><a href="#0x04-evilpackage-被封-2017-05-26-2-00" class="headerlink" title="0x04 evilpackage 被封 (2017-05-26 2:00)"></a>0x04 evilpackage 被封 (2017-05-26 2:00)</h2><p>我专门提交 Issue 的小马甲 <a href="https://github.com/evilpackage" target="_blank" rel="noopener">evilpackage</a> 因为触发了 GitHub 对 Spam 的检测，所以被封号了。早上起床看到消息后，立马写邮件申诉，直到 2017-05-26 13:00 终于回复我的邮件了：</p><img src="http://static.fatezero.org/blog/img/package-fishing/unlock-evilpackage.png"><h2 id="0x05-放弃-webtask-io-2017-05-26-19-00"><a href="#0x05-放弃-webtask-io-2017-05-26-19-00" class="headerlink" title="0x05 放弃 webtask.io (2017-05-26 19:00)"></a>0x05 放弃 webtask.io (2017-05-26 19:00)</h2><p>为了避免和之前一样被恶意插入脏数据，决定要放弃 webtask.io，每月花费 $10 巨款购入一台 vps。</p><p>使用 nginx + flask 的配置，继续将 user data 提交到 GitHub Issues 上。</p><p>nginx 的 <code>ngx_http_limit_req_module</code> 模块最大能够支持 <code>1s/m</code>，也就是最多可以限制每个 ip 在每分钟内最多请求一次，所以我们必须修改 <code>ngx_http_limit_req_module</code> 模块代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/http/modules/ngx_http_limit_req_module.c</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ngx_strncmp(value[i].data, <span class="string">"rate="</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            len = value[i].len;</span><br><span class="line">            p = value[i].data + len - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ngx_strncmp(p, <span class="string">"r/s"</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                scale = <span class="number">1</span>;</span><br><span class="line">                len -= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ngx_strncmp(p, <span class="string">"r/m"</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                scale = <span class="number">60</span>;</span><br><span class="line">                len -= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ngx_strncmp(p, <span class="string">"wtf"</span>, <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                scale = <span class="number">1000</span>;</span><br><span class="line">                len -= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>增加一个 <code>else if</code> block，直接将 scale 增加到 1000，这样就能限制每个 ip 在 16 min 内只能访问一次我们的接口，除非使用大量代理，不然很难在短时间内插入大量脏数据。</p><h2 id="0x06-repo-被封-2017-05-27-3-00"><a href="#0x06-repo-被封-2017-05-27-3-00" class="headerlink" title="0x06 repo 被封 (2017-05-27 3:00)"></a>0x06 repo 被封 (2017-05-27 3:00)</h2><p>早上起床刷新一下 GitHub Issues 页面，结果发现：</p><img src="http://static.fatezero.org/blog/img/package-fishing/lock-repo.png"><p>邮件：</p><img src="http://static.fatezero.org/blog/img/package-fishing/lock-repo-email.png"><p>赶紧先上服务器加上一行代码，将用户上传的数据先暂时存在本地（之前太懒）。然后马上回邮件，问情况，两天后：</p><img src="http://static.fatezero.org/blog/img/package-fishing/lock-repo-response-email.png"><p>解封无望，之前的数据大概就是没了。</p><p>目前还能通过 GitHub Search 找到以前的部分数据 <a href="https://github.com/search?l=&amp;q=repo%3Afate0%2Fcookiecutter-evil-pypackage&amp;ref=advsearch&amp;type=Issues&amp;utf8=%E2%9C%93" target="_blank" rel="noopener">GitHub Issue</a></p><h2 id="0x07-写-web-界面-2017-05-30-19-00"><a href="#0x07-写-web-界面-2017-05-30-19-00" class="headerlink" title="0x07 写 web 界面 (2017-05-30 19:00):"></a>0x07 写 web 界面 (2017-05-30 19:00):</h2><p>由于之前一直在忙，最后拖到了30号才开始写 web 展示界面 <a href="http://evilpackage.fatezero.org/" target="_blank" rel="noopener">http://evilpackage.fatezero.org/</a></p><p>也准备好新的 cookiecutter 模版 <a href="https://github.com/fate0/cookiecutter-evilpy-package/commit/b1a968407b1a94b17298af969727848ad1325cae" target="_blank" rel="noopener">cookiecutter-evilpy-package</a></p><p>新的 cookiecutter 模版会提示用户安装了 evilpackage，并打开用户的浏览器去访问 <a href="http://evilpackage.fatezero.org/" target="_blank" rel="noopener">http://evilpackage.fatezero.org/</a>，让用户知道，自己已经是绵羊墙上的一员了。</p><p>计划打算第二天再往 PyPI 上提交新版本的 Package。</p><h2 id="0x08-清空-2017-05-31"><a href="#0x08-清空-2017-05-31" class="headerlink" title="0x08 清空 (2017-05-31):"></a>0x08 清空 (2017-05-31):</h2><p>早上查找资料的时候发现，原来已经有好几批人干过和我一样类似的事情了</p><ul><li>2013-06-06: <a href="https://pypi.python.org/pypi/requestes" target="_blank" rel="noopener">requestes 0.0.1</a></li><li>2016-01-25: <a href="https://pypi.python.org/pypi/requirements-dev/1.0.0" target="_blank" rel="noopener">requirements-dev 1.0.0</a></li><li>2016-03-17: <a href="http://incolumitas.com/data/thesis.pdf" target="_blank" rel="noopener">Typosquatting in Programming Language Package Managers</a> </li></ul><p>前两批都只是上传一个 package 用来提示安装用户，也防止恶意用户使用这些 package 名字，后面一个小哥和我一样收集了用户不太敏感的信息，只不过他的数据一直没有公开。</p><p>过了一会 @<a href="http://weibo.com/u/1260091985" target="_blank" rel="noopener">ztz</a> 同学告诉我他的 RubyGems 被清空了。</p><p>再过了一会我这边也被 PyPI 管理员警告要删除账号了，所以我就把所有的 Package 给删除了，账号也给删除了。</p><p>目前为止所有的 package 又回到了 unregister 的状态, 任何人都可以继续注册使用我之前注册的 package.</p><h2 id="0x09-数据统计"><a href="#0x09-数据统计" class="headerlink" title="0x09 数据统计"></a>0x09 数据统计</h2><p>目前我只能对在 <a href="http://evilpackage.fatezero.org/" target="_blank" rel="noopener">http://evilpackage.fatezero.org/</a> 上那 10685 条数据进行统计</p><p>从 2017-05-27 10:38:03 到 2017-05-31 18:24:07，总计 106 个小时内，有 9726 不重复的 ip 安装了 evil package，平均每个小时有 91 个 ip 安装了 evil package。</p><ol><li><p>每个 package 命中排名:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2862 opencv</span><br><span class="line">2834 tkinter</span><br><span class="line">810 mkl</span><br><span class="line">789 python-dev</span><br><span class="line">713 git</span><br><span class="line">683 openssl</span><br><span class="line">535 caffe</span><br><span class="line">328 ffmpeg</span><br><span class="line">224 phantomjs</span><br><span class="line">200 smb</span><br><span class="line">191 vtk</span><br><span class="line">179 pygpu</span><br><span class="line">113 mongodb</span><br><span class="line">70 requirement.txt</span><br><span class="line">56 memcached</span><br><span class="line">31 rabbitmq</span><br><span class="line">15 ftp</span><br><span class="line">14 shadowsock</span><br><span class="line">12 samba</span><br><span class="line">10 proxy</span><br><span class="line">10 hbase</span><br><span class="line">5 zookeeper</span><br></pre></td></tr></table></figure></li><li><p>前 50 个国家命中排名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2507 United States</span><br><span class="line">1667 China</span><br><span class="line">772 India</span><br><span class="line">481 Germany</span><br><span class="line">448 Japan</span><br><span class="line">331 France</span><br><span class="line">319 Republic of Korea</span><br><span class="line">306 United Kingdom</span><br><span class="line">305 Russia</span><br><span class="line">297 Canada</span><br><span class="line">225 Brazil</span><br><span class="line">183 Australia</span><br><span class="line">179 Netherlands</span><br><span class="line">167 Poland</span><br><span class="line">147 Taiwan</span><br><span class="line">129 Italy</span><br><span class="line">127 Israel</span><br><span class="line">126 Spain</span><br><span class="line">106 Singapore</span><br><span class="line">103 Ukraine</span><br><span class="line">89 Hong Kong</span><br><span class="line">87 Switzerland</span><br><span class="line">76 Sweden</span><br><span class="line">74 Turkey</span><br><span class="line">60 Ireland</span><br><span class="line">57 Vietnam</span><br><span class="line">57 Iran</span><br><span class="line">54 Belgium</span><br><span class="line">53 Finland</span><br><span class="line">52 Austria</span><br><span class="line">49 Pakistan</span><br><span class="line">49 Indonesia</span><br><span class="line">47 Argentina</span><br><span class="line">43 New Zealand</span><br><span class="line">42 Mexico</span><br><span class="line">41 Romania</span><br><span class="line">40 Thailand</span><br><span class="line">37 Norway</span><br><span class="line">37 Czechia</span><br><span class="line">31 South Africa</span><br><span class="line">31 Denmark</span><br><span class="line">31 Colombia</span><br><span class="line">29 Portugal</span><br><span class="line">29 Greece</span><br><span class="line">29 Chile</span><br><span class="line">24 Philippines</span><br><span class="line">23 Malaysia</span><br><span class="line">20 Hungary</span><br><span class="line">20 Belarus</span><br><span class="line">19 Nepal</span><br></pre></td></tr></table></figure></li><li><p>每个访问排名 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28 114.255.40.3</span><br><span class="line">25 46.105.249.70</span><br><span class="line">16 54.84.16.79</span><br><span class="line">16 54.237.234.187</span><br><span class="line">16 54.157.41.7</span><br><span class="line">16 54.145.106.255</span><br><span class="line">16 52.90.178.211</span><br><span class="line">13 34.198.151.69</span><br><span class="line">12 52.221.7.193</span><br><span class="line">11 54.235.37.25</span><br><span class="line">10 34.224.47.129</span><br><span class="line">9 172.56.26.43</span><br><span class="line">7 94.153.230.50</span><br><span class="line">7 80.239.169.204</span><br><span class="line">7 73.78.62.6</span><br><span class="line">7 54.87.185.66</span><br><span class="line">7 52.207.13.234</span><br><span class="line">7 113.140.11.125</span><br><span class="line">6 52.55.104.10</span><br><span class="line">6 24.108.0.220</span><br></pre></td></tr></table></figure></li></ol><p>光从这几天来看，在 PyPI 上投放 evilpackage 的效果还是非常不错的，每天都会有大概 2200+ 个独立 ip 进行访问，数据量稍微比之前那位小哥好一点，也就是说，即便是类似的文章发出来，过了一年之后，随意安装 package 的这种情况完全没有改善，可能更严重了。</p><p>那位小哥释放掉所有的 package 之后，我作为一个 “恶意者” 再次使用他之前使用的 <code>git</code>、<code>openssl</code> 名字来统计数据，我作为一个 “恶意者”，被官方勒令删除所有的 package，这些 package 名字再次被释放，我比较好奇下一位 “恶意者” 会是谁，会在 package 里放什么？会是和我一样收集数据，还是直接 <code>rm -rf /</code>，还是勒索。拭目以待。</p><h2 id="0x10-requirements-txt"><a href="#0x10-requirements-txt" class="headerlink" title="0x10 requirements.txt"></a>0x10 requirements.txt</h2><p>一般经常使用 Python 的人都知道 <code>requirements.txt</code> 是整个项目的依赖文件，一般这样使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>不过也有可能一时手速过快，敲打成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requirements.txt</span><br></pre></td></tr></table></figure><p>所以 <code>requirements.txt</code> 也是一个比较好的 evil package 的名字</p><h4 id="诡异的-requirements-txt"><a href="#诡异的-requirements-txt" class="headerlink" title="诡异的 requirements.txt"></a>诡异的 <code>requirements.txt</code></h4><p>在 2017-05-24 19:00 晚上，我尝试在 PyPI 注册上传 <code>requirements.txt</code> 的时候：</p><img src="http://static.fatezero.org/blog/img/package-fishing/upload-requirements-failed.png"><p>嗯，都失败了，但是 <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=repo%3Afate0%2Fcookiecutter-evil-pypackage+requirements.txt&amp;type=Issues" target="_blank" rel="noopener">GitHub Issues</a> 上竟然会有 153 个和 <code>requirements.txt</code> 相关的 Issues：</p><img src="http://static.fatezero.org/blog/img/package-fishing/requirements-txt-show-in-issues.png"><p>我并不怀疑这些 <code>requirements.txt</code> 数据的真实性，因为就没有人知道我尝试上传过 <code>requirements.txt</code>，所以这些数据肯定是真实的。</p><p>PyPI 上也并不存在 <code>requirements.txt</code> 信息，本地尝试安装也失败了，至今仍未明白这种情况为何发生。</p><h4 id="绕过-PyPI-requirements-txt-的限制"><a href="#绕过-PyPI-requirements-txt-的限制" class="headerlink" title="绕过 PyPI requirements.txt 的限制"></a>绕过 PyPI <code>requirements.txt</code> 的限制</h4><p>在 PyPI 账号被删除之后，我还是对 <code>requirements.txt</code> 很好奇，为什么之前 GitHub 上会有记录？能不能绕过 PyPI 的限制？下面简单讲一下如何绕过 PyPI 的限制。</p><p>我们直接查看提交 Package 时，PyPI 对 Package 名字限制的地方：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from: https://github.com/pypa/pypi-legacy/blob/master/webui.py#L2429</span></span><br><span class="line"><span class="meta">@must_tls</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit_pkg_info</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    name = data[<span class="string">'name'</span>]</span><br><span class="line">    version = data[<span class="string">'version'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name.lower() <span class="keyword">in</span> (<span class="string">'requirements.txt'</span>, <span class="string">'rrequirements.txt'</span>,</span><br><span class="line">            <span class="string">'requirements-txt'</span>, <span class="string">'rrequirements-txt'</span>):</span><br><span class="line">        <span class="keyword">raise</span> Forbidden, <span class="string">"Package name '%s' invalid"</span> % name</span><br></pre></td></tr></table></figure></p><p>通过上面的代码，我们可以看到 PyPI 直接硬编码 <code>&#39;requirements.txt&#39;, &#39;rrequirements.txt&#39;, &#39;requirements-txt&#39;, &#39;rrequirements-txt&#39;</code> 禁止用户上传这些文件。</p><p>我们再看看 <code>pip install xxx</code> 的时候，PyPI 是怎么查找 Package 的：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from: https://github.com/pypa/pypi-legacy/blob/master/store.py#L611</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_package</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="string">'''Return names of packages that differ from name only in case.'''</span></span><br><span class="line">    cursor = self.get_cursor()</span><br><span class="line">    sql = <span class="string">'select name from packages where normalize_pep426_name(name)=normalize_pep426_name(%s)'</span></span><br><span class="line">    safe_execute(cursor, sql, (name, ))</span><br><span class="line">    <span class="keyword">return</span> [r[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> cursor.fetchall()]</span><br></pre></td></tr></table></figure></p><p>好吧，直接查找数据库，我们再跟下来看 <code>normalize_pep426_name</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from: https://github.com/pypa/warehouse/blob/master/warehouse/migrations/versions/3af8d0006ba_normalize_runs_of_characters_to_a_.py#L27</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upgrade</span><span class="params">()</span>:</span></span><br><span class="line">    op.execute(</span><br><span class="line">        <span class="string">""" CREATE OR REPLACE FUNCTION normalize_pep426_name(text)</span></span><br><span class="line"><span class="string">            RETURNS text AS</span></span><br><span class="line"><span class="string">            $$</span></span><br><span class="line"><span class="string">                SELECT lower(regexp_replace($1, '(\.|_|-)+', '-', 'ig'))</span></span><br><span class="line"><span class="string">            $$</span></span><br><span class="line"><span class="string">            LANGUAGE SQL</span></span><br><span class="line"><span class="string">            IMMUTABLE</span></span><br><span class="line"><span class="string">            RETURNS NULL ON NULL INPUT;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    )</span><br><span class="line">    op.execute(<span class="string">"REINDEX INDEX project_name_pep426_normalized"</span>)</span><br></pre></td></tr></table></figure></p><p>看到中间那个正则了吧，这也就意味着 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install youtube-dl</span><br><span class="line">pip install youtube_dl</span><br><span class="line">pip install youtube.dl</span><br><span class="line">pip install youtube-_-dl</span><br><span class="line">pip install youtube.-.dl</span><br></pre></td></tr></table></figure></p><p>这几条命令其实都是等价的，都是在安装 <code>youtube_dl</code>, 那么我们就可以很容易的就绕过 PyPI 的限制，直接上传一个 <code>requiremnets--txt</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">twine register dist/requirements--txt-0.1.0.tar.gz</span><br><span class="line">twine upload dist/requirements--txt-0.1.0.tar.gz</span><br></pre></td></tr></table></figure><p>来来来，我们直接尝试 <code>pip install requirements.txt</code>：</p><img src="http://static.fatezero.org/blog/img/package-fishing/install-requirements--txt.png"><p>通过上面的图，我们可以看到 PyPI 已经返回我们的 package url，到了 pip 准备安装这个 package 的时候报错了，所以直接看 pip 代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/pypa/pip/blob/master/pip/index.py#L650</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> version:</span><br><span class="line">    version = egg_info_matches(egg_info, search.supplied, link)</span><br><span class="line"><span class="keyword">if</span> version <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    self._log_skipped_link(</span><br><span class="line">        link, <span class="string">'wrong project name (not %s)'</span> % search.supplied)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>看了代码，也就是没法在 url 中获取 package 的版本号，因为 package 的名字(<code>requirements--txt</code>)和搜索名字(<code>requirements.txt</code>)对不上，我们得找找其他方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://github.com/pypa/pip/blob/master/pip/index.py#L626</span></span><br><span class="line"><span class="keyword">if</span> ext == wheel_ext:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        wheel = Wheel(link.filename)</span><br><span class="line">    <span class="keyword">except</span> InvalidWheelFilename:</span><br><span class="line">        self._log_skipped_link(link, <span class="string">'invalid wheel filename'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> canonicalize_name(wheel.name) != search.canonical:</span><br><span class="line">        self._log_skipped_link(</span><br><span class="line">            link, <span class="string">'wrong project name (not %s)'</span> % search.supplied)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> wheel.supported(self.valid_tags):</span><br><span class="line">        self._log_skipped_link(</span><br><span class="line">            link, <span class="string">'it is not compatible with this Python'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    version = wheel.version</span><br></pre></td></tr></table></figure><p>看到这里，大家应该也知道了，之前我们一直都是使用 source 的方式提交 package，如果我们直接打包成 wheel，根据上面的代码，就不会再报错了，我们重新打包，再次上传：</p><img src="http://static.fatezero.org/blog/img/package-fishing/upload-requirements-success.png"><p>终于成功了，当然 wheel 安装方式并不能直接执行命令，不过我们可以通过给 <code>requirements.txt</code> 添加一个恶意依赖达到执行任意代码的效果。</p><p>在这里，我就添加了一个名为 <code>ztz</code> 的 source package，用于提醒安装 <code>requirements.txt</code> 的用户</p><img src="http://static.fatezero.org/blog/img/package-fishing/ztz.png"><h2 id="0x11-总结"><a href="#0x11-总结" class="headerlink" title="0x11 总结"></a>0x11 总结</h2><p>最后还是提一下我是怎么被 PyPI 官方发现的，原因非常简单，我之前每个 evil package 都是用同一个 cookiecutter 模版生成，而每个模版的 short desc 都是 <code>just for fun : )</code>，所以在 <a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">PyPI 首页</a> 刷了一排 <code>just for fun : )</code>。就是因为这样简单的理由被发现。</p><p>但是如果，我为每个 evil package 准备不同模版，为每个 evil package 准备文档， 为每个 evil package 准备不同的 PyPI account 上传，每次上传使用不同 ip，在 PyPI 没有审核机制的情况下，是很难将所有的 evil package 一网打尽，只能靠别人 report。</p><p>所以防御方案就完全不可能期待 PyPI 会做什么，只能提升自我对信息安全意识，对 PyPI 上不熟悉的项目一律采取不可信的态度，意识到随意 <code>pip install</code> 就和随意的执行 <code>exe</code> 一样危险。</p><p>想做一件坏事情真不容易，快去看看 <a href="http://evilpackage.fatezero.org/" target="_blank" rel="noopener">http://evilpackage.fatezero.org/</a> 上面有没有你的名字。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;前几天 &lt;code&gt;Samba&lt;/code&gt; 公开了一个远程代码执行的漏洞，然后各种 POC 也随之出现，
&lt;code&gt;exploit-db&lt;/code&gt; 上也有这样一个 Python 版本的 &lt;a href=&quot;https://www.exploit-db.com/exploits/42060/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POC:  Samba 3.5.0 - Remote Code Execution&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解密 RubyEncoder</title>
    <link href="http://blog.fatezero.org/2017/02/26/decrypt-rubyencoder/"/>
    <id>http://blog.fatezero.org/2017/02/26/decrypt-rubyencoder/</id>
    <published>2017-02-26T18:47:24.000Z</published>
    <updated>2018-11-13T03:28:47.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>RubyEncoder 是一款对 Ruby 代码进行混淆加密的软件，因为最近我要破解某个使用 RubyEncoder 加密的 Ruby 程序，所以工作就转移到如何解密 RubyEncoder 加密的程序。</p><a id="more"></a><h2 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h2><p>要想了解 RubyEncoder，那肯定是要去<a href="https://www.rubyencoder.com/trial.html?cm_id=151&amp;action=submit_trial" target="_blank" rel="noopener">官网</a>下载一份试用版，但是无论你怎么填写试用资料：</p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-not-allow-regist.png"><p>我隐约记得 Hacking Team RCS 也用了 RubyEncoder，所以比较幸运的，我从 <a href="https://wikileaks.org/hackingteam/emails/?q=rubyencoder&amp;mfrom=&amp;mto=&amp;title=&amp;notitle=&amp;date=&amp;nofrom=&amp;noto=&amp;count=50&amp;sort=0#searchresult" target="_blank" rel="noopener">Hacking Team 邮件</a> 中找到了一个可以登陆账号密码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Username: alor@hackingteam.it</span><br><span class="line">Password: Oyf4GSy0</span><br></pre></td></tr></table></figure><p>下载到了 RubyEncoder-2.3，并偷偷的使用 Hacking Team 一个 License Key 成功激活了 RubyEncoder</p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-registration.png"><p>先简单试用一下 RubyEncoder</p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-encrypt.png"><p>上图是 RubyEncoder 对某个项目加密的主界面，在这个界面中可以看到，我们可以选择支持的 Ruby 版本。由于因为可以选多个版本号以及 1.8.x 也在支持的版本内，所以可以判定加密后的文件不会是 iseq 或者修改后的 iseq。</p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/rubyencoder-lock-options.png"><p>上图是 RubyEncoder 支持的加密选项，可以进行 IP、Domain、MAC、联网、时间、License 限制。其中除了 License 文件之外，其他都是纸老虎，如果 License 文件没有参与对文件的加密，那 License 限制也是纸老虎。不过根据官方文档描述</p><blockquote><p>The algorithm uses an idea of two keys. The first key (Project Id) is stored in the encrypted area of the protected script and is used to decrypt an external license file. The second key (Project Key) is stored in the license file and it is used to decrypt the bytecode from the protected script.</p></blockquote><p>所以如果没有 License 文件是很难将程序跑起来的，不过这篇文章的目的不是怎么样解除这些限制，而是如何解密 RubyEncoder 加密后的 Ruby 代码。</p><p>我们再来看一下 RubyEncoder 的目录结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Loaders</span><br><span class="line">│   ├── Linux</span><br><span class="line">│   │   ├── loader.rb</span><br><span class="line">│   │   ├── my.so</span><br><span class="line">│   │   ├── rgloader.linux.so</span><br><span class="line">│   │   ├── rgloader.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader19.linux.so</span><br><span class="line">│   │   ├── rgloader19.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader192.linux.so</span><br><span class="line">│   │   ├── rgloader192.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader193.linux.so</span><br><span class="line">│   │   ├── rgloader193.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader20.linux.so</span><br><span class="line">│   │   ├── rgloader20.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader21.linux.so</span><br><span class="line">│   │   ├── rgloader21.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader22.linux.so</span><br><span class="line">│   │   ├── rgloader22.linux.x86_64.so</span><br><span class="line">│   │   ├── rgloader23.linux.so</span><br><span class="line">│   │   └── rgloader23.linux.x86_64.so</span><br><span class="line">│   ├── Mac\ OS\ X // 省略 ..</span><br><span class="line">│   ├── MinGW // 省略 ...</span><br><span class="line">│   └── Windows // 省略 ...</span><br><span class="line">├── RubyEncoder</span><br><span class="line">├── license.txt</span><br><span class="line">├── licgen</span><br><span class="line">├── rgencoder</span><br><span class="line">├── rginfo</span><br><span class="line">├── rubyencoder18.bundle</span><br><span class="line">├── rubyencoder19.bundle</span><br><span class="line">├── rubyencoder192.bundle</span><br><span class="line">├── rubyencoder20.bundle</span><br><span class="line">├── rubyencoder21.bundle</span><br><span class="line">├── rubyencoder22.bundle</span><br><span class="line">├── rubyencoder23.bundle</span><br><span class="line">└── update</span><br></pre></td></tr></table></figure><p>简单看了一下 <code>rubyencoder*.bundle</code> 文件，应该是直接把整个 Ruby 给打包进来了，应该是加密的过程中需要 Ruby 的一些功能，不过我并不是特别关注加密过程，所以直接看 <code>Loaders</code> 目录下的文件，这个目录下包含了所支持的平台下、Ruby 版本的解密 so 文件。</p><p>当然除了需要下载 RubyEncoder 程序，还需要找一找有没有前辈已经搞定这个程序的，google 一番之后找到 <a href="https://www.ruby-forum.com/topic/168409#741854" target="_blank" rel="noopener">I found way to protect Source Code! :)</a> 这个帖子。</p><p>这个帖子的思路是：</p><ol><li>将 <code>ruby_exec</code> 修改成 <code>ruby_exic</code> 以便获得 AST</li><li>使用修改后的 <code>ParseTree</code> 将 Ruby 内部的 AST 转成 sexp</li><li>使用 <code>ruby2ruby</code> 将 sexp 转成 Ruby 代码</li></ol><p>不过这个帖子当时使用的是 <code>Ruby 1.8.7</code>，也就是当时 Ruby 还是构建完 AST 之后就直接执行，1.9.x 后的 Ruby 需要编译成 iseq。另外由于 <code>Ruby 1.8</code> 和 <code>Ruby 2.x</code> 有很大的不同，上面的 <code>ParseTree</code> 在 Ruby 使用 iseq 之后就再也不能使用了。所以上面的方法在 <code>Ruby 2.x</code> 中行不通了。</p><h2 id="0x02-简单逆向"><a href="#0x02-简单逆向" class="headerlink" title="0x02 简单逆向"></a>0x02 简单逆向</h2><p>我们使用 RubyEncoder 对以下代码进行加密</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">puts <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure><p>得到下面加密后的代码</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RubyEncoder v2.3.0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.respond_to?(<span class="symbol">:RGLoader_load</span>,<span class="symbol">:include_private</span>) <span class="keyword">then</span> _d = _d<span class="number">0</span> = File.expand_path(File.dirname(__FILE_<span class="number">_</span>)); <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span> _f = _d + <span class="string">'/rgloader/loader.rb'</span>; <span class="keyword">break</span> <span class="keyword">if</span> File.exist?(_f); _d1 = File.dirname(_d); <span class="keyword">if</span> _d1 == _d <span class="keyword">then</span> raise <span class="string">"Ruby script '"</span>+__FILE_<span class="number">_</span>+<span class="string">"' is protected by RubyEncoder and requires a RubyEncoder loader to be installed. Please visit the http://www.rubyencoder.com/loaders/ RubyEncoder web site to download the required loader and unpack it into '"</span>+_d<span class="number">0</span>+<span class="string">"/rgloader/' directory in order to run this protected file."</span>; exit; <span class="keyword">else</span> _d = _d1; <span class="keyword">end</span>; <span class="keyword">end</span>; <span class="keyword">require</span> _f; <span class="keyword">end</span>; RGLoader_load(<span class="string">'AAIAAAAEgAAAAIAAAAAA/0R/d65ujW/5OhgbeUf0jhTRfPXr0uXNuC7gK8ycmR473fPEIlsgFP1/KF+CYBVbQy4xoLUhBFtBlYwH2aDOtcTasNDJPMDtoEgRuRdFRDgJoX1oKhrm0ZKm9OdIM6MbXRc/fh4n984TVew76DqbxQTplVhMxzOCp/mKgLU+shxBFAAAAGAAAAA7Nu8kj4NtO8BQECP2bW1TonmX+NADX/HETWg1j5fvbB8gptZ38XCzJxOccT2CTUsTT8GFq67RttUD7IR/xN2FBCWKMZ1BlGYVlhSmSUc6hS5RfglTuyvdVdjnsgcnkTAVAAAAYAAAAIrxSQfPHlMc89mPBUXSQ6vxmM9yoDu7Rf+O87mTUW4L0VuAWkIhvFUBxXRVm6Q7kkWHg7D7cdIwwA62+ewy91l56aMIQujAKZrVn4T1zreKf1QdGvK+QGY4rIpGEmTBhBYAAABoAAAADdYzBFrSrrZ4o9uzaoq+Yxjk44lzEa+/oxXM7fmbm8gJ1W3MlUZyPqIjW01KUb6nZjWIAz629+KP5nL/GMP0BClkOjpXQ9b95R/qvlDzuP7UZHPeqaIJq2yMN7Mh9WROfAhLlhmK86AXAAAAcAAAAGgSDy/YvPJQsKnC+JvR+ITlVdWPGodUNT10I0CPLu9d81hMtEL9hU4t9yVfBcS2BWDqBg3ahhUTvqNYxwvX8NCHmZU4LQmdd3dJneWJzGy6VbAQeVDNeaJl8/SPdRn1VXaspqWGYFn1cXqp7rhHLUcAAAAA'</span>);</span><br></pre></td></tr></table></figure><p>可以看到最关键的函数就是 <code>RGLoader_load</code>，所以直接将 <code>rgloader22.linux.x86_64.so</code> 丢进 IDA，找到 <code>RGLoader_load</code> 的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">rgloader_load</span><span class="params">(<span class="keyword">int</span> a1, _DWORD *a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略 ...</span></span><br><span class="line">    v126 = v124;</span><br><span class="line">    v127 = _decode_node(v124);</span><br><span class="line">    mstream_close(v126);</span><br><span class="line">    ruby_xfree(v23);</span><br><span class="line">    <span class="keyword">if</span> ( !v127 || decoder_error )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_243;</span><br><span class="line">    v128 = *(_DWORD *)(rb_thread_current() + <span class="number">16</span>);</span><br><span class="line">    v210 = *(_DWORD *)(v128 + <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> ( a1 == rgloader_module )</span><br><span class="line">        *(_DWORD *)(v128 + <span class="number">60</span>) = *(_DWORD *)(*(_DWORD *)(v128 + <span class="number">24</span>) + <span class="number">56</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *(_DWORD *)(v128 + <span class="number">60</span>) = *(_DWORD *)(*(_DWORD *)(v128 + <span class="number">24</span>) + <span class="number">16</span>);</span><br><span class="line">    v129 = (<span class="keyword">char</span> *)rg_current_realfilepath();</span><br><span class="line">    v130 = rb_sourcefile();</span><br><span class="line">    v131 = rb_str_new_cstr(v130);</span><br><span class="line">    v132 = rb_str_new_static(<span class="string">"&lt;encoded&gt;"</span>, <span class="number">9</span>);</span><br><span class="line">    v133 = rb_iseq_new(v127, v132, v131, v129, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    result = rb_iseq_eval(v133);</span><br><span class="line">    *(_DWORD *)(v128 + <span class="number">60</span>) = v210;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，事实上，RubyEncoder 就算是到了 2.3 版本，还是和上面那个帖子所说的一样：</p><blockquote><p>It turns out, that RubyEncoder uses following scheme: modifiedRuby-1.8.7 interpreter,that stores encoded AST nodes along with encoding/restriction options,while rgloader simply decodes it back to AST and executes.</p></blockquote><p>只不过这里多了一步 <code>v133 = rb_iseq_new(v127, v132, v131, v129, 0, 0);</code> 将 AST 编译成 iseq。</p><p>我们可以通过 hook <code>rb_iseq_new</code> 拿到 AST，hook <code>rb_iseq_eval</code> 拿到 iseq。</p><p>下面我们修改 Ruby 代码将 AST 以及 iseq dump 出来。</p><ol><li><p>one byte hack</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp rgloader22.linux.x86_64.so bak.so</span><br><span class="line">sed <span class="string">'s/rb_iseq_eval/rb_iseq_evax/g'</span> rgloader22.linux.x86_64.so &gt; tmp.so</span><br><span class="line">sed <span class="string">'s/rb_iseq_new/rb_iseq_nex/g'</span> tmp.so &gt; rgloader22.linux.x86_64.so</span><br></pre></td></tr></table></figure></li><li><p>在 <code>iseq.c</code> 中实现 <code>rb_iseq_nex</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VALUE</span><br><span class="line">rb_iseq_nex(NODE *node, VALUE name, VALUE path, VALUE absolute_path,</span><br><span class="line">            VALUE parent, <span class="keyword">enum</span> iseq_type type)</span><br><span class="line">&#123;</span><br><span class="line">    rb_io_write(rb_stdout, rb_parser_dump_tree(node, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> rb_iseq_new(node, name, path, absolute_path, parent, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 <code>vm.c</code> 中实现 <code>rb_iseq_evax</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VALUE</span><br><span class="line">rb_iseq_evax(VALUE iseqval)</span><br><span class="line">&#123;</span><br><span class="line">    rb_io_write(rb_stdout, rb_iseq_disasm(iseqval));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>结果:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###########################################################</span><br><span class="line">## Do NOT use this node dump for any purpose other than  ##</span><br><span class="line">## debug and research.  Compatibility is not guaranteed. ##</span><br><span class="line">###########################################################</span><br><span class="line"></span><br><span class="line"># @ NODE_SCOPE (line: 1)</span><br><span class="line"># +- nd_tbl: (empty)</span><br><span class="line"># +- nd_args:</span><br><span class="line"># |   (null node)</span><br><span class="line"># +- nd_body:</span><br><span class="line">#     @ NODE_FCALL (line: 1)</span><br><span class="line">#     +- nd_mid: :puts</span><br><span class="line">#     +- nd_args:</span><br><span class="line">#         @ NODE_ARRAY (line: 1)</span><br><span class="line">#         +- nd_alen: 1</span><br><span class="line">#         +- nd_head:</span><br><span class="line">#         |   @ NODE_STR (line: 1)</span><br><span class="line">#         |   +- nd_lit: &quot;Hello World!&quot;</span><br><span class="line">#         +- nd_next:</span><br><span class="line">#             (null node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">== disasm: &lt;RubyVM::InstructionSequence:&lt;encoded&gt;@./ruby-2.2.6/hello.rb&gt;</span><br><span class="line">0000 trace            1                                               (   1)</span><br><span class="line">0002 putself</span><br><span class="line">0003 putstring        &quot;Hello World!&quot;</span><br><span class="line">0005 opt_send_without_block &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SIMPLE&gt;</span><br><span class="line">0007 leave</span><br></pre></td></tr></table></figure></p><p>上面就是 dump 出来的 AST 和 iseq，不过这些离我们的最终目标还有一点点距离。</p><h2 id="0x03-生成代码"><a href="#0x03-生成代码" class="headerlink" title="0x03 生成代码"></a>0x03 生成代码</h2><p>由于之前的 <code>parsetree</code> 已经不能再使用了，google了一番之后，也没有找到现成的，之前的打算是写一个类似 Python 的 uncompyle 之类的东西, 解析 iseq 结构、构建 AST、生成代码，不过后面发现自己实在没那么多时间，于是就偷懒直接从 Ruby 的 AST 直接生成代码。</p><p>对照着 Ruby 的 <code>node.c</code>、<code>parse.y</code>、<code>compile.c</code> 就可以写出</p><p><a href="https://gist.github.com/fate0/a1851bb39efe177bec20dbcd4445f6f3" target="_blank" rel="noopener">node2ruby.c</a></p><p>试试看这个代码反编译的效果，测试文件 <a href="https://github.com/ruby/ruby/blob/ruby_2_2/lib/net/http.rb" target="_blank" rel="noopener">http.rb</a></p><img src="http://static.fatezero.org/blog/img/decrypt-rubyencoder/decrypt-result.png"><p>感觉效果还是差强人意，代码算是可以能看的，但是想要执行起来还要继续对代码进行修改(因为<a href="https://gist.github.com/fate0/a1851bb39efe177bec20dbcd4445f6f3" target="_blank" rel="noopener">node2ruby.c</a> 还有挺多地方没考虑到的) </p><p>总的来说，Ruby 写的代码还是比较友好的，像我这样的新手都能很快上手，嗯，除了有些小错误外，顺手给 Ruby 提交了两 PR：</p><ul><li><a href="https://github.com/ruby/ruby/pull/1528" target="_blank" rel="noopener">node.c: fix NODE_OP_ASGN1 operator</a></li><li><a href="https://github.com/ruby/ruby/pull/1529" target="_blank" rel="noopener">node.c: fix nd_ainfo-&gt;kw_rest_arg</a></li></ul><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>写 <a href="https://gist.github.com/fate0/a1851bb39efe177bec20dbcd4445f6f3" target="_blank" rel="noopener">node2ruby.c</a> 的时候就觉得如果不是特别熟悉 Ruby 的话，有些比较奇怪的语句还是想不到的。</p><p>对了，还记得我们上面所说的，如果没有 License 文件，就很难将程序跑起来么？嗯，我要解密的 Ruby 代码就是必须要 License 文件的，而且我还没有 License。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;RubyEncoder 是一款对 Ruby 代码进行混淆加密的软件，因为最近我要破解某个使用 RubyEncoder 加密的 Ruby 程序，
所以工作就转移到如何解密 RubyEncoder 加密的程序。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阴阳师：一个非酋的逆向旅程</title>
    <link href="http://blog.fatezero.org/2017/01/14/decrypt-onmyoji/"/>
    <id>http://blog.fatezero.org/2017/01/14/decrypt-onmyoji/</id>
    <published>2017-01-14T12:15:11.000Z</published>
    <updated>2018-11-13T03:28:47.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>为了验证这个游戏到底有没有 SSR</p><a id="more"></a><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>怕了怕了</p><p><a href="https://www.baidu.com/s?wd=阴阳师：一个非酋的逆向旅程" target="_blank" rel="noopener">阴阳师:一个非酋的逆向旅程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;为了验证这个游戏到底有没有 SSR&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Komm, süsser Tod</title>
    <link href="http://blog.fatezero.org/2016/12/21/Komm-susser-Tod/"/>
    <id>http://blog.fatezero.org/2016/12/21/Komm-susser-Tod/</id>
    <published>2016-12-21T22:53:27.000Z</published>
    <updated>2018-11-13T03:28:47.692Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的意义在于测试这个主题所支持的功能</p><a id="more"></a><h2 id="测试-MarkDown-功能"><a href="#测试-MarkDown-功能" class="headerlink" title="测试 MarkDown 功能"></a>测试 MarkDown 功能</h2><h4 id="0x1-表格"><a href="#0x1-表格" class="headerlink" title="0x1. 表格"></a>0x1. 表格</h4><table><thead><tr><th style="text-align:left">靠左表头</th><th style="text-align:center">居中表头</th><th style="text-align:right">靠右表头</th></tr></thead><tbody><tr><td style="text-align:left"><code>content</code></td><td style="text-align:center">内容</td><td style="text-align:right">$a=1$</td></tr><tr><td style="text-align:left"><em>内容</em></td><td style="text-align:center">$a^3$</td><td style="text-align:right"><strong>内容</strong></td></tr></tbody></table><h4 id="0x2-代码"><a href="#0x2-代码" class="headerlink" title="0x2. 代码"></a>0x2. 代码</h4><p>这里是代码块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure><p>这里是行内代码 <code>print(&quot;hello world&quot;)</code></p><h4 id="0x3-引用"><a href="#0x3-引用" class="headerlink" title="0x3. 引用"></a>0x3. 引用</h4><blockquote><p>这里是引用第二行引用</p></blockquote><h4 id="0x4-链接"><a href="#0x4-链接" class="headerlink" title="0x4. 链接"></a>0x4. 链接</h4><p><a href="http://blog.fatezero.org">我的博客</a><a href="http://wiki.fatezero.org" target="_blank" rel="noopener">我的wiki</a></p><h4 id="0x5-图片"><a href="#0x5-图片" class="headerlink" title="0x5. 图片"></a>0x5. 图片</h4><p><img src="https://octodex.github.com/images/privateinvestocat.jpg" alt="privateinvestocat"></p><h2 id="测试-mathjax"><a href="#测试-mathjax" class="headerlink" title="测试 mathjax"></a>测试 mathjax</h2><p>这里是数学公式块</p>$$        \begin{matrix}        1 & x & x^2 \\        1 & y & y^2 \\        1 & z & z^2 \\        \end{matrix}$$<p>这个是行内数学公式 $\sqrt[4]{\frac xy}$</p><h2 id="测试-Hexo-功能"><a href="#测试-Hexo-功能" class="headerlink" title="测试 Hexo 功能"></a>测试 Hexo 功能</h2><h4 id="0x1-img"><a href="#0x1-img" class="headerlink" title="0x1. img"></a>0x1. img</h4><img src="https://octodex.github.com/images/privateinvestocat.jpg" width="200" height="200"><p>一般使用 Hexo 内的图片 tag, 因为可以调整图片大小</p><h4 id="0x2-raw"><a href="#0x2-raw" class="headerlink" title="0x2. raw"></a>0x2. raw</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><h4 id="0x3-主题-tip"><a href="#0x3-主题-tip" class="headerlink" title="0x3. 主题 tip"></a>0x3. 主题 tip</h4><div class="tip">    这个是主题带的 tip</div><h4 id="0x4-iframe"><a href="#0x4-iframe" class="headerlink" title="0x4. iframe"></a>0x4. iframe</h4><iframe src="//www.fatezero.org" width="500" height="86" frameborder="0" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章的意义在于测试这个主题所支持的功能&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
