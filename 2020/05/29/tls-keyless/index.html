<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> TLS Keyless 技术探索 · fate0</title><meta name="description" content="TLS Keyless 技术探索 - fate0"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.fatezero.org/atom.xml" title="fate0"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?345ca1db7809172aec8db3a78e7679c4";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://www.fatezero.org" target="_blank" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">TLS Keyless 技术探索</h1><div class="post-info">May 29, 2020</div><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>随着 https 全线推广，证书私钥散落在各处，不便于管理，
而且一旦服务器被黑客 takeover，或者再次出现像 heartbleed 一样的漏洞，证书私钥就面临着被泄漏的风险，所以我们需要探索一种能够保护服务器证书私钥的技术方案。</p>
<a id="more"></a>
<h2 id="0x01-ngx-ssl"><a href="#0x01-ngx-ssl" class="headerlink" title="0x01 ngx.ssl"></a>0x01 ngx.ssl</h2><p>第一种方案将证书放置于远程服务器，定时将证书私钥从 keyserver 拉到 webserver 内存中进行 tls sign/decrypt 操作。</p>
<!--
sequenceDiagram
    client ->> webserver: https 连接
    webserver ->> keyserver: 请求获取链接对应证书及私钥
    keyserver ->> webserver: 返回证书及私钥
    webserver ->> webserver: 设置证书及私钥，并进行运算
    webserver ->> client: 返回 response
-->
<img src="http://static.fatezero.org/blog/img/tls-keyless/ngx.ssl.svg">
<p>具体实现可以使用 OpenResty ngx.ssl 模块中 <code>ssl.set_der_cert</code> 和 <code>ssl.set_der_priv_key</code> 为当前连接动态设置证书及私钥：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- modify from https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md#synopsis</span></span><br><span class="line">ssl_certificate_by_lua_block &#123;</span><br><span class="line">    <span class="keyword">local</span> ssl = <span class="built_in">require</span> <span class="string">"ngx.ssl"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 清除当前连接证书</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = ssl.clear_certs()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(ngx.ERROR)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 自定义函数 my_load_certificate_chain 加载远程证书</span></span><br><span class="line">    <span class="keyword">local</span> pem_cert_chain = <span class="built_in">assert</span>(my_load_certificate_chain())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> der_cert_chain, err = ssl.cert_pem_to_der(pem_cert_chain)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> der_cert_chain <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(ngx.ERROR)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 为当前连接设置证书</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = ssl.set_der_cert(der_cert_chain)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(ngx.ERROR)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 自定义函数 my_load_private_key 加载远程证书私钥</span></span><br><span class="line">    <span class="keyword">local</span> pem_pkey = <span class="built_in">assert</span>(my_load_private_key())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> der_pkey, err = ssl.priv_key_pem_to_der(pem_pkey)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> der_pkey <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(ngx.ERROR)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 为当前连接设置证书私钥</span></span><br><span class="line">    <span class="keyword">local</span> ok, err = ssl.set_der_priv_key(der_pkey)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(ngx.ERROR)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方案的优点是：</p>
<ol>
<li>实现简单</li>
<li>证书私钥不落盘</li>
<li>证书私钥能够在统一的节点进行管理</li>
</ol>
<p>缺点只有一个，服务器被 takeover 或者再一次发生 heartbleed 的时候，证书还是有可能会被泄漏</p>
<h2 id="0x02-keyless"><a href="#0x02-keyless" class="headerlink" title="0x02 keyless"></a>0x02 keyless</h2><p>第二种方案将证书放置于远程服务器，将 tls 链接中需要 sign/decrypt 的参数提供给 keyserver，让 keyserver 进行 sign/decrypt 操作。</p>
<!--
sequenceDiagram
    client ->> webserver: https 连接
    webserver ->> keyserver: 提供 tls handshake 中相关的 params 信息
    keyserver ->> keyserver: 使用对应的私钥对 params 进行 sign/decrypt
    keyserver ->> webserver: 返回计算后的结果
    webserver ->> client: 返回 response
-->
<img src="http://static.fatezero.org/blog/img/tls-keyless/keyless.svg">
<p>提出这种方案的是 Cloudflare: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">Keyless SSL: The Nitty Gritty Technical Details</a>，主要是为了给那些不愿意提供自己证书的客户使用，那 keyless 适用于甲方内部吗？cloudflare 内部也在尝试：<a href="https://blog.cloudflare.com/zh/going-keyless-everywhere-zh/" target="_blank" rel="noopener">Going Keyless Everywhere</a>，主要是为了把 web 服务器和证书进行分离，防止服务器被 takeover 后证书泄漏。在目前(2019-11)为止，cloudflare 在 TLS 1.3 流量和 Spectrum 业务上使用了 keyless 。</p>
<p>在实现上，我们先用比较流行的 Nginx + OpenSSL 做分析，那么目前有没有其他将 TLS 中非对称加解密的操作从 OpenSSL 中剥离出来的方案呢？有，那就是 “intel QAT 异步加速方案”。</p>
<p>intel QAT 主要依靠 OpenSSL 的两个特性 <code>OpenSSL ASYNC</code> 和 <code>OpenSSL Engine</code> 来搭配实现。</p>
<p><code>OpenSSL ASYNC</code> 能够在 async_job 执行过程中，在等待加速卡结果的时候，将 cpu 让出去，在没启用 async 模式时，调用 openssl 函数是阻塞操作：</p>
<img src="http://static.fatezero.org/blog/img/tls-keyless/qat_sync.png" width="500">
<p>开启之后则是非阻塞的调用：</p>
<img src="http://static.fatezero.org/blog/img/tls-keyless/qat_async.png" width="300">
<p><a href="https://www.openssl.org/blog/blog/2015/10/08/engine-building-lesson-1-a-minimum-useless-engine/" target="_blank" rel="noopener"><code>OpenSSL Engine</code></a> 则是提供了自定义注册加解密的方法，不使用 OpenSSL 自带的加解密库，转而自己实现或者调用第三方的加解密库</p>
<p>我们再看一下 async_job 执行流：</p>
<img src="http://static.fatezero.org/blog/img/tls-keyless/qat_flow.png" width="500">
<p>那我们是不是可以和 intel QAT 一样在 Nginx 启用 OpenSSL ASYNC 模式，然后再利用 OpenSSL Engine 调用 keyless server 呢？
如果你的 nginx server 只有一份证书，那没问题，但不同的 server_name 使用不一样的证书的时候，可能就不行了，我们先看一下 <code>EVP_CIPHER</code> 结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nid;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* init key */</span></span><br><span class="line">    <span class="keyword">int</span> (*init) (EVP_CIPHER_CTX *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key,</span><br><span class="line">                 <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">int</span> enc);</span><br><span class="line">    <span class="comment">/* encrypt/decrypt data */</span></span><br><span class="line">    <span class="keyword">int</span> (*do_cipher) (EVP_CIPHER_CTX *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *out,</span><br><span class="line">                      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *in, <span class="keyword">size_t</span> inl);</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125; <span class="comment">/* EVP_CIPHER */</span> ;</span><br></pre></td></tr></table></figure>
<p>再看一下 <code>EVP_CIPHER_CTX</code> 结构：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_ctx_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> EVP_CIPHER *cipher;</span><br><span class="line">    ENGINE *engine;             <span class="comment">/* functional reference if 'cipher' is</span></span><br><span class="line"><span class="comment">                                 * ENGINE-provided */</span></span><br><span class="line">    <span class="keyword">int</span> encrypt;                <span class="comment">/* encrypt or decrypt */</span></span><br><span class="line">    <span class="keyword">int</span> buf_len;                <span class="comment">/* number we have left */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oiv[EVP_MAX_IV_LENGTH]; <span class="comment">/* original iv */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> iv[EVP_MAX_IV_LENGTH]; <span class="comment">/* working iv */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[EVP_MAX_BLOCK_LENGTH]; <span class="comment">/* saved partial block */</span></span><br><span class="line">    <span class="keyword">int</span> num;                    <span class="comment">/* used by cfb/ofb/ctr mode */</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">FIXME:</span> Should this even exist? It appears unused */</span></span><br><span class="line">    <span class="keyword">void</span> *app_data;             <span class="comment">/* application stuff */</span></span><br><span class="line">    <span class="keyword">int</span> key_len;                <span class="comment">/* May change for variable length cipher */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;        <span class="comment">/* Various flags */</span></span><br><span class="line">    <span class="keyword">void</span> *cipher_data;          <span class="comment">/* per EVP data */</span></span><br><span class="line">    <span class="keyword">int</span> final_used;</span><br><span class="line">    <span class="keyword">int</span> block_mask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">final</span>[EVP_MAX_BLOCK_LENGTH]; <span class="comment">/* possible final block */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Provider ctx */</span></span><br><span class="line">    <span class="keyword">void</span> *provctx;</span><br><span class="line">    EVP_CIPHER *fetched_cipher;</span><br><span class="line">&#125; <span class="comment">/* EVP_CIPHER_CTX */</span> ;</span><br></pre></td></tr></table></figure></p>
<p>我没有发现有可以和 SSL_CTX 关联的字段，也就是说在实际的加解密操作函数中是没法获取当前 handshake 相关信息，
也就没有办法告诉 keyless server 该使用哪一个私钥去做 sign/decrypt 操作，其实还是有变相解决的方法：
提供一个 fake 私钥给 openssl engine，转而提供给 keyless server，从而使用 fake 私钥找到 true 私钥。</p>
<p>Cloudflare 应该不是使用这种方式去实现，因为 Cloudflare 发布技术细节的时间是 2014-09 ，然而 2015-11 时 OpenSSL才支持 async mode。</p>
<p>考虑到对 nginx + openssl 进行修改比较复杂，我选择了 nginx 同类产品 <a href="https://github.com/baidu/bfe" target="_blank" rel="noopener">bfe</a> 进行修改。
因为 Go 的 crypto/tls 模块相比 openssl 模块要容易修改的多，而 bfe 的 bfe_tls 模块就是拉取官方 crypto/tls 模块进行二次修改的，
除了代码落后官方代码好几年之外，也没什么太大的缺点。将 keyless 模块整合进去，需要拉去官方几个 commit 的代码，
而且 bfe 提供了设置第三方 cert 提供策略 <code>bfe_tls.SetTlsMultiCertificate</code> 可以很方便的实现整个 keyless 方案。</p>
<p>我的实现：<a href="https://github.com/fate0/bfe" target="_blank" rel="noopener">BFE with keyless</a>，具体安装以及测试信息都在 README 中。</p>
<p>这种方案的优点是：</p>
<ol>
<li>即便 webserver 被 takeover，也不会泄漏证书私钥</li>
<li>证书私钥能够做到统一管理</li>
</ol>
<p>缺点是：</p>
<ol>
<li>实现复杂</li>
<li>gokeyless license 问题 (不确定到底能不能公司内部使用，不过实现比较简单)</li>
</ol>
<h2 id="0x03-Delegated-Credentials-for-TLS"><a href="#0x03-Delegated-Credentials-for-TLS" class="headerlink" title="0x03 Delegated Credentials for TLS"></a>0x03 Delegated Credentials for TLS</h2><p>Keyless 方案最大的问题是每个 client 的新连接都需要 Web Server 往 Keyless Server 发送 sign/decrypt 请求，
在甲方内部 Web Server 和 Keyless Server 一般都在同一机房，这种情况还能接受。但是像 Cloudflare 这样的 CDN 厂商，
CDN Server 和 Keyless Server 相隔可能十万八千里的，这问题就严重了，所以 
<a href="https://blog.cloudflare.com/keyless-delegation/" target="_blank" rel="noopener">Cloudflare</a>/
<a href="https://engineering.fb.com/security/delegated-credentials/" target="_blank" rel="noopener">Facebook</a>/
<a href="https://blog.mozilla.org/security/2019/11/01/validating-delegated-credentials-for-tls-in-firefox/" target="_blank" rel="noopener">Mozilla</a> 提出了 RFC: 
<a href="https://tools.ietf.org/html/draft-ietf-tls-subcerts-07" target="_blank" rel="noopener">Delegated Credential for TLS</a></p>
<!--
sequenceDiagram
    client ->> webserver: https 连接
    loop 每小时
        keyserver ->> webserver: 推送 delegated credential
    end
    webserver ->> webserver: 设置证书及私钥，并进行运算
    webserver ->> client: 返回 response
-->
<img src="http://static.fatezero.org/blog/img/tls-keyless/dc.svg">
<p>简单描述就是由真正的证书生成 Delegated Credential (失效时间几小时)，然后将 Delegated Credential 提供给 webserver 当作正常证书进行使用。在 keyless 场景就是 keyless server 生成 Delegated Credential，而后将 Delegated Credential 推送给 CDN 使用 (和正常的证书一样使用)</p>
<p>严格来说 Delegated Credential 并不是一种 keyless 方案，但也能很好的对私钥进行保护，我也不确定 cloudflare 得到 Delegated Credential 后还是不是继续走方案二这一套，但如果在小米内部，则可以不使用方案二，直接将 Delegated Credential 当正常证书使用，反正证书失效时间只有几小时。可惜的是方案三的 RFC 还没定下来，而且只支持 TLS1.3 而且现在只有 nightly firefox 支持，所以方案三目前来说完全不可行。</p>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>第一种方案没有达到要求，第三种方案目前还没落地，目前只有第二种方案能符合要求，TLS Keyless 方案小米内部也在不断的尝试中，将来也有可能会推广到其他非 https 的场景中，
如果你对这个项目感兴趣，或者对漏洞扫描器、WAF、IoT 自动化安全与评估、日志审计等安全项目感兴趣，那么欢迎你加入我们</p>
<h2 id="0x05-引用"><a href="#0x05-引用" class="headerlink" title="0x05 引用"></a>0x05 引用</h2><ul>
<li><a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/</a></li>
<li><a href="https://blog.cloudflare.com/zh/going-keyless-everywhere-zh/" target="_blank" rel="noopener">https://blog.cloudflare.com/zh/going-keyless-everywhere-zh/</a></li>
<li><a href="https://blog.cloudflare.com/keyless-delegation/" target="_blank" rel="noopener">https://blog.cloudflare.com/keyless-delegation/</a></li>
<li><a href="https://engineering.fb.com/security/delegated-credentials/" target="_blank" rel="noopener">https://engineering.fb.com/security/delegated-credentials/</a></li>
<li><a href="https://blog.mozilla.org/security/2019/11/01/validating-delegated-credentials-for-tls-in-firefox/" target="_blank" rel="noopener">https://blog.mozilla.org/security/2019/11/01/validating-delegated-credentials-for-tls-in-firefox/</a></li>
<li><a href="https://tools.ietf.org/html/draft-ietf-tls-subcerts-07" target="_blank" rel="noopener">https://tools.ietf.org/html/draft-ietf-tls-subcerts-07</a></li>
<li><a href="https://github.com/fate0/bfe" target="_blank" rel="noopener">https://github.com/fate0/bfe</a></li>
<li><a href="https://github.com/baidu/bfe" target="_blank" rel="noopener">https://github.com/baidu/bfe</a></li>
<li><a href="https://01.org/sites/default/files/downloads/intelr-quickassist-technology/intelquickassisttechnologyopensslperformance.pdf" target="_blank" rel="noopener">https://01.org/sites/default/files/downloads/intelr-quickassist-technology/intelquickassisttechnologyopensslperformance.pdf</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/07/15/web-scanner-trick/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2020 <a href="http://blog.fatezero.org">fate0</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">apollo</a>.</p></div></footer></div></body></html>